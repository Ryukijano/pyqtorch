{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pyqtorch","text":"<p><code>pyqtorch</code> is an efficient, large-scale emulator designed for quantum machine learning, seamlessly integrated with a PyTorch backend.</p>"},{"location":"#setup","title":"Setup","text":"<p>To install <code>pyqtorch</code> , you can go into any virtual environment of your choice and install it normally with <code>pip</code> (including extra dependencies for development):</p> <pre><code>pip install pyqtorch\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to Contribute","text":"<p>We're grateful for your interest in participating in pyqtorch! Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an Issue or Proposing a Feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to PyQ, feel free to create an issue on pyqtorch's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>We're excited that you're eager to contribute to pyqtorch! To contribute, fork the <code>main</code> branch of pyqtorch repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/pyqtorch</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/pyqtorch.git\n</code></pre> <p>Next, navigate to your new pyqtorch fork directory and mark the main pyqtorch repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/pyqtorch.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within pyqtorch, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run pyqtorch tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\n\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful Things for your workflow: Linting and Testing","text":"<p>Use <code>pre-commit</code> hooks to make sure that the code is properly linted before pushing a new commit. Make sure that the unit tests and type checks are passing since the merge request will not be accepted if the automatic CI/CD pipeline do not pass.</p> <p>Without <code>hatch</code>:</p> <pre><code>pip install pytest\n\npip install -e .\npip install pre-commit\npre-commit install\npre-commit run --all-files\npytest\n</code></pre> <p>And with <code>hatch</code>:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Make sure your docs build too!</p> <p>With <code>hatch</code>:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"QAOA/","title":"QAOA","text":"In\u00a0[45]: Copied! <pre>import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.nn.init as init\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nimport pyqtorch.modules as pyq\n</pre> import torch import torch.nn as nn import torch.nn.functional as F import torch.nn.init as init  import numpy as np import matplotlib.pyplot as plt import networkx as nx  import pyqtorch.modules as pyq In\u00a0[46]: Copied! <pre>np.random.seed(0)\nn_nodes = 10\n\ngraph = nx.gnp_random_graph(n_nodes, .25, seed=42)\nnx.draw(graph, with_labels=True)\n</pre> np.random.seed(0) n_nodes = 10  graph = nx.gnp_random_graph(n_nodes, .25, seed=42) nx.draw(graph, with_labels=True) In\u00a0[47]: Copied! <pre>from pyqtorch.matrices import generate_ising_from_graph, sum_N\n\nising_matrix = generate_ising_from_graph(graph, type_ising='N')\nising_cost = 1.2*ising_matrix - sum_N(n_nodes)\n\nising_matrix = ising_matrix.reshape([2] * n_nodes + [1])\nising_cost = ising_cost.reshape([2] * n_nodes + [1])\n\n\nclass MIS(nn.Module):\n    def __init__(self, n_qubits, n_layers):\n        super().__init__()\n        self.n_qubits = n_qubits\n        self.gamma = nn.Parameter(torch.empty(n_layers,))\n        self.ansatz = pyq.VariationalLayer(n_qubits, pyq.RX)\n        self.reset_parameters()\n        \n    def reset_parameters(self):\n        init.uniform_(self.gamma, -2 * np.pi, 2 * np.pi)\n        self.ansatz.reset_parameters()\n        \n    def forward(self, return_cost=False):\n        state = pyq.uniform_state(self.n_qubits)\n        for g in self.gamma:\n            state = state * torch.exp(-1j * g * ising_matrix)\n            state = self.ansatz(state)\n        if return_cost:\n            return torch.real(torch.sum(torch.abs(state)**2 * ising_cost))\n        else:\n            state = state.reshape((2**self.n_qubits,))\n            return torch.abs(state)**2\n</pre> from pyqtorch.matrices import generate_ising_from_graph, sum_N  ising_matrix = generate_ising_from_graph(graph, type_ising='N') ising_cost = 1.2*ising_matrix - sum_N(n_nodes)  ising_matrix = ising_matrix.reshape([2] * n_nodes + [1]) ising_cost = ising_cost.reshape([2] * n_nodes + [1])   class MIS(nn.Module):     def __init__(self, n_qubits, n_layers):         super().__init__()         self.n_qubits = n_qubits         self.gamma = nn.Parameter(torch.empty(n_layers,))         self.ansatz = pyq.VariationalLayer(n_qubits, pyq.RX)         self.reset_parameters()              def reset_parameters(self):         init.uniform_(self.gamma, -2 * np.pi, 2 * np.pi)         self.ansatz.reset_parameters()              def forward(self, return_cost=False):         state = pyq.uniform_state(self.n_qubits)         for g in self.gamma:             state = state * torch.exp(-1j * g * ising_matrix)             state = self.ansatz(state)         if return_cost:             return torch.real(torch.sum(torch.abs(state)**2 * ising_cost))         else:             state = state.reshape((2**self.n_qubits,))             return torch.abs(state)**2 In\u00a0[48]: Copied! <pre>model = MIS(n_nodes, 20)\n\noptimizer = torch.optim.Adam(model.parameters(), lr=.02)\nepochs = 100\n\n\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    loss = model(True)\n    loss.backward()\n    optimizer.step()\n    if epoch%50 == 0:\n        print(f\"Epoch {epoch} | Loss {loss}\")\n</pre> model = MIS(n_nodes, 20)  optimizer = torch.optim.Adam(model.parameters(), lr=.02) epochs = 100   for epoch in range(epochs):     optimizer.zero_grad()     loss = model(True)     loss.backward()     optimizer.step()     if epoch%50 == 0:         print(f\"Epoch {epoch} | Loss {loss}\") <pre>Epoch 0 | Loss 1.4900727366440991\nEpoch 50 | Loss 1.1838491896514012\n</pre> In\u00a0[49]: Copied! <pre>prob = model()\nmis = torch.argmax(prob)\nformat(mis, '010b')\n</pre> prob = model() mis = torch.argmax(prob) format(mis, '010b') Out[49]: <pre>'1111101000'</pre> In\u00a0[50]: Copied! <pre>mis\n</pre> mis Out[50]: <pre>tensor(1000)</pre> In\u00a0[51]: Copied! <pre>\"{0:b}\".format(1)\n</pre> \"{0:b}\".format(1) Out[51]: <pre>'1'</pre> In\u00a0[52]: Copied! <pre>sum_N(n_nodes)[mis]\n</pre> sum_N(n_nodes)[mis] Out[52]: <pre>tensor(6.+0.j, dtype=torch.complex128)</pre>"},{"location":"QAOA/#solve-mis-for-qaoa","title":"Solve MIS for QAOA\u00b6","text":""},{"location":"apply_gate/","title":"Apply gate","text":""},{"location":"circuit/","title":"Circuit","text":""},{"location":"circuit/#pyqtorch.modules.circuit.EntanglingLayer","title":"<code>EntanglingLayer</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>class EntanglingLayer(QuantumCircuit):\n    def __init__(self, n_qubits: int):\n        \"\"\"\n        Represents an entangling layer in a quantum neural network by entangling Qubits\n\n        Args:\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Example:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        from pyqtorch.modules.circuit import EntanglingLayer\n\n        # Create an entangling layer with 4 qubits\n        entangling_layer = EntanglingLayer(n_qubits=4)\n\n        print(entangling_layer)\n        ```\n        \"\"\"\n        operations = ModuleList(\n            [CNOT([i % n_qubits, (i + 1) % n_qubits], n_qubits) for i in range(n_qubits)]\n        )\n        super().__init__(n_qubits, operations)\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.EntanglingLayer.__init__","title":"<code>__init__(n_qubits)</code>","text":"<p>Represents an entangling layer in a quantum neural network by entangling Qubits</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Example: <pre><code>from pyqtorch.modules.circuit import EntanglingLayer\n\n# Create an entangling layer with 4 qubits\nentangling_layer = EntanglingLayer(n_qubits=4)\n\nprint(entangling_layer)\n</code></pre> <pre><code>EntanglingLayer(\n  (operations): ModuleList(\n    (0): CNOT(qubits=[0, 1], n_qubits=4)\n    (1): CNOT(qubits=[1, 2], n_qubits=4)\n    (2): CNOT(qubits=[2, 3], n_qubits=4)\n    (3): CNOT(qubits=[3, 0], n_qubits=4)\n  )\n)\n</code></pre></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>def __init__(self, n_qubits: int):\n    \"\"\"\n    Represents an entangling layer in a quantum neural network by entangling Qubits\n\n    Args:\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Example:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from pyqtorch.modules.circuit import EntanglingLayer\n\n    # Create an entangling layer with 4 qubits\n    entangling_layer = EntanglingLayer(n_qubits=4)\n\n    print(entangling_layer)\n    ```\n    \"\"\"\n    operations = ModuleList(\n        [CNOT([i % n_qubits, (i + 1) % n_qubits], n_qubits) for i in range(n_qubits)]\n    )\n    super().__init__(n_qubits, operations)\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.QuantumCircuit","title":"<code>QuantumCircuit</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>class QuantumCircuit(Module):\n    def __init__(self, n_qubits: int, operations: list):\n        \"\"\"\n        Creates a QuantumCircuit that can be used to compose multiple gates\n        from a list of operations.\n\n        Arguments:\n            n_qubits (int): The total number of qubits in the circuit.\n            operations (list): A list of gate operations to be applied in the circuit.\n\n        Example:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        #create a circuit with 2 qubits than provide a list of operations .\n        #in this example we apply a X gate followed by a CNOT gate.\n        circ = pyq.QuantumCircuit(\n                                    n_qubits=2,\n                                    operations=[\n                                        pyq.X([0], 2),\n                                        pyq.CNOT([0,1], 2)\n                                    ]\n                                )\n        #create a zero state\n        z = pyq.zero_state(2)\n\n        #apply the circuit and its list of operations onto the zero state\n        result=circ(z)\n\n        #print the result\n        print(result) #tensor([[[0.+0.j],[0.+0.j]],[[0.+0.j],[1.+0.j]]], dtype=torch.complex128)\n        ```\n        \"\"\"\n        super().__init__()\n        self.n_qubits = n_qubits\n        self.operations = torch.nn.ModuleList(operations)\n\n    def __mul__(self, other: AbstractGate | QuantumCircuit) -&gt; QuantumCircuit:\n        if isinstance(other, QuantumCircuit):\n            n_qubits = max(self.n_qubits, other.n_qubits)\n            return QuantumCircuit(n_qubits, self.operations.extend(other.operations))\n\n        if isinstance(other, AbstractGate):\n            n_qubits = max(self.n_qubits, other.n_qubits)\n            return QuantumCircuit(n_qubits, self.operations.append(other))\n\n        else:\n            return ValueError(f\"Cannot compose {type(self)} with {type(other)}\")\n\n    def __key(self) -&gt; tuple:\n        return (self.n_qubits, *self.operations)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if isinstance(other, QuantumCircuit):\n            return self.__key() == other.__key()\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        return hash(self.__key())\n\n    def forward(self, state: torch.Tensor, thetas: torch.Tensor = None) -&gt; torch.Tensor:\n        \"\"\"\n        Forward pass of the quantum circuit.\n\n        Arguments:\n            state (torch.Tensor): The input quantum state tensor.\n            thetas (torch.Tensor): Optional tensor of parameters for the circuit operations.\n\n        Returns:\n            torch.Tensor: The output quantum state tensor after applying the circuit operations.\n\n        \"\"\"\n        for op in self.operations:\n            state = op(state, thetas)\n        return state\n\n    @property\n    def _device(self) -&gt; torch.device:\n        try:\n            (_, buffer) = next(self.named_buffers())\n            return buffer.device\n        except StopIteration:\n            return torch.device(\"cpu\")\n\n    def init_state(self, batch_size: int) -&gt; torch.Tensor:\n        return zero_state(self.n_qubits, batch_size, device=self._device)\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.QuantumCircuit.__init__","title":"<code>__init__(n_qubits, operations)</code>","text":"<p>Creates a QuantumCircuit that can be used to compose multiple gates from a list of operations.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <code>operations</code> <code>list</code> <p>A list of gate operations to be applied in the circuit.</p> required <p>Example: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n#create a circuit with 2 qubits than provide a list of operations .\n#in this example we apply a X gate followed by a CNOT gate.\ncirc = pyq.QuantumCircuit(\n                            n_qubits=2,\n                            operations=[\n                                pyq.X([0], 2),\n                                pyq.CNOT([0,1], 2)\n                            ]\n                        )\n#create a zero state\nz = pyq.zero_state(2)\n\n#apply the circuit and its list of operations onto the zero state\nresult=circ(z)\n\n#print the result\nprint(result) #tensor([[[0.+0.j],[0.+0.j]],[[0.+0.j],[1.+0.j]]], dtype=torch.complex128)\n</code></pre> <pre><code>tensor([[[0.+0.j],\n         [0.+0.j]],\n\n        [[0.+0.j],\n         [1.+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>def __init__(self, n_qubits: int, operations: list):\n    \"\"\"\n    Creates a QuantumCircuit that can be used to compose multiple gates\n    from a list of operations.\n\n    Arguments:\n        n_qubits (int): The total number of qubits in the circuit.\n        operations (list): A list of gate operations to be applied in the circuit.\n\n    Example:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    #create a circuit with 2 qubits than provide a list of operations .\n    #in this example we apply a X gate followed by a CNOT gate.\n    circ = pyq.QuantumCircuit(\n                                n_qubits=2,\n                                operations=[\n                                    pyq.X([0], 2),\n                                    pyq.CNOT([0,1], 2)\n                                ]\n                            )\n    #create a zero state\n    z = pyq.zero_state(2)\n\n    #apply the circuit and its list of operations onto the zero state\n    result=circ(z)\n\n    #print the result\n    print(result) #tensor([[[0.+0.j],[0.+0.j]],[[0.+0.j],[1.+0.j]]], dtype=torch.complex128)\n    ```\n    \"\"\"\n    super().__init__()\n    self.n_qubits = n_qubits\n    self.operations = torch.nn.ModuleList(operations)\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.QuantumCircuit.forward","title":"<code>forward(state, thetas=None)</code>","text":"<p>Forward pass of the quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Tensor</code> <p>The input quantum state tensor.</p> required <code>thetas</code> <code>Tensor</code> <p>Optional tensor of parameters for the circuit operations.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: The output quantum state tensor after applying the circuit operations.</p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>def forward(self, state: torch.Tensor, thetas: torch.Tensor = None) -&gt; torch.Tensor:\n    \"\"\"\n    Forward pass of the quantum circuit.\n\n    Arguments:\n        state (torch.Tensor): The input quantum state tensor.\n        thetas (torch.Tensor): Optional tensor of parameters for the circuit operations.\n\n    Returns:\n        torch.Tensor: The output quantum state tensor after applying the circuit operations.\n\n    \"\"\"\n    for op in self.operations:\n        state = op(state, thetas)\n    return state\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.VariationalLayer","title":"<code>VariationalLayer</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>class VariationalLayer(QuantumCircuit):\n    def __init__(self, n_qubits: int, Op: Any):\n        \"\"\"\n        Represents a variational layer in a quantum neural network allowing you\n        to create a trainable QuantumCircuit.\n        If you want the angles of your circuit to be trainable you can use a VariationalLayer.\n        The VariationalLayer ignores the second input (because it has trainable angle parameters).\n\n        Arguments:\n            n_qubits (int): The total number of qubits in the circuit.\n            Op (Any): The quantum operation to be applied in the variational layer.\n\n\n        Example:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n        #create a variational layer with 3 qubits and operation of RX as the second parameter\n        circ = pyq.VariationalLayer(n_qubits=3, Op=pyq.RX)\n        state = pyq.zero_state(3)\n        this_argument_is_ignored = None\n        result=circ(state, this_argument_is_ignored)\n        print(result)\n        ```\n        \"\"\"\n        operations = ModuleList([Op([i], n_qubits) for i in range(n_qubits)])\n        super().__init__(n_qubits, operations)\n\n        self.thetas = Parameter(torch.empty(n_qubits, Op.n_params))\n        self.reset_parameters()\n\n    def reset_parameters(self) -&gt; None:\n        init.uniform_(self.thetas, -2 * torch.pi, 2 * torch.pi)\n\n    def forward(self, state: torch.Tensor, _: torch.Tensor = None) -&gt; torch.Tensor:\n        for op, t in zip(self.operations, self.thetas):\n            state = op(state, t)\n        return state\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.VariationalLayer.__init__","title":"<code>__init__(n_qubits, Op)</code>","text":"<p>Represents a variational layer in a quantum neural network allowing you to create a trainable QuantumCircuit. If you want the angles of your circuit to be trainable you can use a VariationalLayer. The VariationalLayer ignores the second input (because it has trainable angle parameters).</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <code>Op</code> <code>Any</code> <p>The quantum operation to be applied in the variational layer.</p> required <p>Example: <pre><code>import torch\nimport pyqtorch.modules as pyq\n#create a variational layer with 3 qubits and operation of RX as the second parameter\ncirc = pyq.VariationalLayer(n_qubits=3, Op=pyq.RX)\nstate = pyq.zero_state(3)\nthis_argument_is_ignored = None\nresult=circ(state, this_argument_is_ignored)\nprint(result)\n</code></pre> <pre><code>tensor([[[[-0.9208+0.0000j],\n          [ 0.0000+0.2779j]],\n\n         [[ 0.0000-0.2554j],\n          [-0.0771+0.0000j]]],\n\n\n        [[[ 0.0000-0.0568j],\n          [-0.0171+0.0000j]],\n\n         [[ 0.0157+0.0000j],\n          [ 0.0000-0.0048j]]]], grad_fn=&lt;ViewBackward0&gt;)\n</code></pre></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>def __init__(self, n_qubits: int, Op: Any):\n    \"\"\"\n    Represents a variational layer in a quantum neural network allowing you\n    to create a trainable QuantumCircuit.\n    If you want the angles of your circuit to be trainable you can use a VariationalLayer.\n    The VariationalLayer ignores the second input (because it has trainable angle parameters).\n\n    Arguments:\n        n_qubits (int): The total number of qubits in the circuit.\n        Op (Any): The quantum operation to be applied in the variational layer.\n\n\n    Example:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n    #create a variational layer with 3 qubits and operation of RX as the second parameter\n    circ = pyq.VariationalLayer(n_qubits=3, Op=pyq.RX)\n    state = pyq.zero_state(3)\n    this_argument_is_ignored = None\n    result=circ(state, this_argument_is_ignored)\n    print(result)\n    ```\n    \"\"\"\n    operations = ModuleList([Op([i], n_qubits) for i in range(n_qubits)])\n    super().__init__(n_qubits, operations)\n\n    self.thetas = Parameter(torch.empty(n_qubits, Op.n_params))\n    self.reset_parameters()\n</code></pre>"},{"location":"circuit/#pyqtorch.modules.circuit.FeaturemapLayer","title":"<code>FeaturemapLayer(n_qubits, Op)</code>","text":"<p>Creates a feature map layer in a quantum neural network. The FeaturemapLayer is a convenience constructor for a QuantumCircuit which accepts an operation to put on every qubit.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <code>Op</code> <code>Any</code> <p>The quantum operation to be applied in the feature map layer.</p> required <p>Returns:</p> Name Type Description <code>QuantumCircuit</code> <code>QuantumCircuit</code> <p>The feature map layer represented as a QuantumCircuit.</p> <p>Example: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n#create a FeaturemapLayer to apply the RX operation on all 3 Qubits\ncirc = pyq.FeaturemapLayer(n_qubits=3, Op=pyq.RX)\nprint(circ)\n\nstates = pyq.zero_state(n_qubits=3, batch_size=4)\ninputs = torch.rand(4)\n\n# the same batch of inputs are passed to the operations\ncirc(states, inputs).shape\n</code></pre> <pre><code>QuantumCircuit(\n  (operations): ModuleList(\n    (0): RX(qubits=[0], n_qubits=3)\n    (1): RX(qubits=[1], n_qubits=3)\n    (2): RX(qubits=[2], n_qubits=3)\n  )\n)\n</code></pre></p> Source code in <code>pyqtorch/modules/circuit.py</code> <pre><code>def FeaturemapLayer(n_qubits: int, Op: Any) -&gt; QuantumCircuit:\n    \"\"\"\n    Creates a feature map layer in a quantum neural network.\n    The FeaturemapLayer is a convenience constructor for a QuantumCircuit\n    which accepts an operation to put on every qubit.\n\n    Arguments:\n        n_qubits (int): The total number of qubits in the circuit.\n        Op (Any): The quantum operation to be applied in the feature map layer.\n\n    Returns:\n        QuantumCircuit: The feature map layer represented as a QuantumCircuit.\n\n    Example:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    #create a FeaturemapLayer to apply the RX operation on all 3 Qubits\n    circ = pyq.FeaturemapLayer(n_qubits=3, Op=pyq.RX)\n    print(circ)\n\n    states = pyq.zero_state(n_qubits=3, batch_size=4)\n    inputs = torch.rand(4)\n\n    # the same batch of inputs are passed to the operations\n    circ(states, inputs).shape\n    ```\n    \"\"\"\n    operations = [Op([i], n_qubits) for i in range(n_qubits)]\n    return QuantumCircuit(n_qubits, operations)\n</code></pre>"},{"location":"essentials/","title":"Essentials","text":"In\u00a0[\u00a0]: Copied! <pre>import torch\nimport pyqtorch.modules as pyq\n\ngate = pyq.X(qubits=[0], n_qubits=1)\nz = pyq.zero_state(n_qubits=1)\n\ngate(z)\n</pre> import torch import pyqtorch.modules as pyq  gate = pyq.X(qubits=[0], n_qubits=1) z = pyq.zero_state(n_qubits=1)  gate(z) In\u00a0[\u00a0]: Copied! <pre>gate = pyq.CNOT(qubits=[0,1], n_qubits=2)\nz = pyq.zero_state(n_qubits=2)\ngate(z)\n</pre> gate = pyq.CNOT(qubits=[0,1], n_qubits=2) z = pyq.zero_state(n_qubits=2) gate(z) In\u00a0[\u00a0]: Copied! <pre>z.shape\n</pre> z.shape <p>In <code>pyqtorch</code> the state is a <code>n_qubit+1</code> dimensional <code>Tensor</code>, for example a state with 3 qubits has the shape <code>(2, 2, 2, 1)</code> (i.e. one dimension for each qubit, plus one dimension for the batch size).</p> <p>NOTE: We always work with batched state in <code>pyqtorch</code>.</p> In\u00a0[\u00a0]: Copied! <pre>z = pyq.zero_state(n_qubits=3)\nprint(z.shape)\nz = pyq.zero_state(n_qubits=3, batch_size=5)\nprint(z.shape)\n</pre> z = pyq.zero_state(n_qubits=3) print(z.shape) z = pyq.zero_state(n_qubits=3, batch_size=5) print(z.shape) In\u00a0[\u00a0]: Copied! <pre>circ = pyq.QuantumCircuit(\n    n_qubits=2,\n    operations=[\n        pyq.X([0], 2),\n        pyq.CNOT([0,1], 2)\n    ]\n)\n\nz = pyq.zero_state(2)\ncirc(z)\n</pre> circ = pyq.QuantumCircuit(     n_qubits=2,     operations=[         pyq.X([0], 2),         pyq.CNOT([0,1], 2)     ] )  z = pyq.zero_state(2) circ(z) <p>Every gate and circuit in <code>pyqtorch</code> accepts a state and an optional tensor of angles. If the gate/circuit does not depend on any angles, the second argument is ignored.</p> In\u00a0[\u00a0]: Copied! <pre>theta = torch.rand(1)\ncirc(z, theta)  # theta is ignored\n</pre> theta = torch.rand(1) circ(z, theta)  # theta is ignored In\u00a0[\u00a0]: Copied! <pre>circ = pyq.QuantumCircuit(\n    n_qubits=2,\n    operations=[\n        pyq.RX([0], 2), # rotation instead of X gate\n        pyq.CNOT([0,1], 2)\n    ]\n)\n\ncirc(z, theta)  # theta is used!\n</pre> circ = pyq.QuantumCircuit(     n_qubits=2,     operations=[         pyq.RX([0], 2), # rotation instead of X gate         pyq.CNOT([0,1], 2)     ] )  circ(z, theta)  # theta is used! <p>The vanilla <code>QuantumCircuit</code> is always passing the same <code>theta</code> tensor to its operations, meaning the <code>forward</code> method of the circuit is:</p> <pre>class QuantumCircuit(torch.nn.Module):\n\n    # ...\n\n    def forward(self, state: torch.Tensor, thetas: torch.Tensor = None) -&gt; torch.Tensor:\n        for op in self.operations:\n            state = op(state, thetas)\n        return state\n</pre> <p>The <code>FeaturemapLayer</code> is a convenience constructor for a <code>QuantumCircuit</code> which accepts an operation to put on every qubit.</p> In\u00a0[\u00a0]: Copied! <pre>circ = pyq.FeaturemapLayer(n_qubits=3, Op=pyq.RX)\nprint(circ)\n\nstates = pyq.zero_state(n_qubits=3, batch_size=4)\ninputs = torch.rand(4)\n\n# the same batch of inputs are passed to the operations\ncirc(states, inputs).shape\n</pre> circ = pyq.FeaturemapLayer(n_qubits=3, Op=pyq.RX) print(circ)  states = pyq.zero_state(n_qubits=3, batch_size=4) inputs = torch.rand(4)  # the same batch of inputs are passed to the operations circ(states, inputs).shape In\u00a0[\u00a0]: Copied! <pre>circ = pyq.VariationalLayer(n_qubits=3, Op=pyq.RX)\n\nstate = pyq.zero_state(3)\nthis_argument_is_ignored = None\ncirc(state, this_argument_is_ignored)\n</pre> circ = pyq.VariationalLayer(n_qubits=3, Op=pyq.RX)  state = pyq.zero_state(3) this_argument_is_ignored = None circ(state, this_argument_is_ignored) In\u00a0[\u00a0]: Copied! <pre>def hea(n_qubits: int, n_layers: int) -&gt; pyq.QuantumCircuit:\n    ops = []\n    for _ in range(n_layers):\n        ops.append(pyq.VariationalLayer(n_qubits, pyq.RX))\n        ops.append(pyq.VariationalLayer(n_qubits, pyq.RY))\n        ops.append(pyq.VariationalLayer(n_qubits, pyq.RX))\n        ops.append(pyq.EntanglingLayer(n_qubits))\n    return pyq.QuantumCircuit(n_qubits, ops)\n\ncirc = hea(3,2)\nprint(circ)\n\nstate = pyq.zero_state(3)\ncirc(state)\n</pre> def hea(n_qubits: int, n_layers: int) -&gt; pyq.QuantumCircuit:     ops = []     for _ in range(n_layers):         ops.append(pyq.VariationalLayer(n_qubits, pyq.RX))         ops.append(pyq.VariationalLayer(n_qubits, pyq.RY))         ops.append(pyq.VariationalLayer(n_qubits, pyq.RX))         ops.append(pyq.EntanglingLayer(n_qubits))     return pyq.QuantumCircuit(n_qubits, ops)  circ = hea(3,2) print(circ)  state = pyq.zero_state(3) circ(state)"},{"location":"essentials/#gates","title":"Gates\u00b6","text":"<p><code>pyqtorch</code> implements most of the commonly used gates like Pauli gates, rotation gates, and controlled gates. Every gate accepts a sequence of <code>qubits</code> on which it operates and a total number <code>n_qubits</code> of the state that it will operate on:</p>"},{"location":"essentials/#circuits","title":"Circuits\u00b6","text":""},{"location":"essentials/#quantumcircuit","title":"<code>QuantumCircuit</code>\u00b6","text":"<p>To compose multiple gates we use a <code>QuantumCircuit</code> which is constructed from a list of operations.</p>"},{"location":"essentials/#trainable-quantumcircuits-aka-variationallayers","title":"Trainable <code>QuantumCircuit</code>s aka <code>VariationalLayer</code>s\u00b6","text":"<p>If you want the angles of your circuit to be trainable you can use a <code>VariationalLayer</code>. The <code>VariationalLayer</code> ignores the second input (because it has trainable angle parameters).</p>"},{"location":"essentials/#composing-quantumcircuits","title":"Composing <code>QuantumCircuit</code>s\u00b6","text":"<p>As every gate and circuit in <code>pyqtorch</code> accept the same arguments we can easily compose them to larger circuits, i.e. to implement a hardware efficient ansatz:</p>"},{"location":"fit_function/","title":"Fitting a 1D function","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport torch\n\nimport pyqtorch.modules as pyq\n</pre> import numpy as np import matplotlib.pyplot as plt import torch  import pyqtorch.modules as pyq <p>Let's define a target function we want to fit.</p> In\u00a0[2]: Copied! <pre>def target_function(x, degree=3):\n    result = 0\n    for i in range(degree):\n        result += torch.cos(i*x) + torch.sin(i*x)\n    return .05 * result\n\nx = torch.tensor(np.linspace(0, 10, 100))\ntarget_y = target_function(x, 5)\n\nplt.plot(x.numpy(), target_y.numpy(), label=\"truth\")\nplt.legend()\nplt.show()\n</pre>  def target_function(x, degree=3):     result = 0     for i in range(degree):         result += torch.cos(i*x) + torch.sin(i*x)     return .05 * result  x = torch.tensor(np.linspace(0, 10, 100)) target_y = target_function(x, 5)  plt.plot(x.numpy(), target_y.numpy(), label=\"truth\") plt.legend() plt.show() <p>To fit this function with a QNN we need an entangling ansatz. We will use a layer of <code>U</code>-gates and a layer of <code>CNOT</code>s:</p> In\u00a0[3]: Copied! <pre>def ULayerAnsatz(n_qubits, n_layers):\n    ops = []\n    for _ in range(n_layers):\n        ops.append(pyq.VariationalLayer(n_qubits, pyq.U))\n        ops.append(pyq.EntanglingLayer(n_qubits))\n    return pyq.QuantumCircuit(n_qubits, ops)\n\nULayerAnsatz(3,1)\n</pre> def ULayerAnsatz(n_qubits, n_layers):     ops = []     for _ in range(n_layers):         ops.append(pyq.VariationalLayer(n_qubits, pyq.U))         ops.append(pyq.EntanglingLayer(n_qubits))     return pyq.QuantumCircuit(n_qubits, ops)  ULayerAnsatz(3,1) Out[3]: <pre>QuantumCircuit(\n  (operations): ModuleList(\n    (0): VariationalLayer(\n      (operations): ModuleList(\n        (0): U(qubits=[0], n_qubits=3)\n        (1): U(qubits=[1], n_qubits=3)\n        (2): U(qubits=[2], n_qubits=3)\n      )\n    )\n    (1): EntanglingLayer(\n      (operations): ModuleList(\n        (0): CNOT(qubits=[0, 1], n_qubits=3)\n        (1): CNOT(qubits=[1, 2], n_qubits=3)\n        (2): CNOT(qubits=[2, 0], n_qubits=3)\n      )\n    )\n  )\n)</pre> <p>We can define a QNN by implementing a custom <code>torch.nn.Module</code>.</p> In\u00a0[4]: Copied! <pre>class Model(torch.nn.Module):\n\n    def __init__(self, n_qubits, n_layers):\n        super().__init__()\n        self.n_qubits = n_qubits\n        self.ansatz1 = ULayerAnsatz(n_qubits, n_layers)\n        self.embedding = pyq.FeaturemapLayer(n_qubits, pyq.RX)\n        self.ansatz2 = ULayerAnsatz(n_qubits, n_layers)\n        self.observable = pyq.Z([0], n_qubits)\n        \n    def forward(self, x):\n        batch_size = len(x)\n        state = self.ansatz1.init_state(batch_size)\n        \n        state = self.ansatz1(state)\n        state = self.embedding(state, x)\n        state = self.ansatz2(state)\n        \n        new_state = self.observable(state)\n        \n        state = state.reshape((2**self.n_qubits, batch_size))\n        new_state = new_state.reshape((2**self.n_qubits, batch_size))\n        return torch.real(torch.sum(torch.conj(state) * new_state, axis=0))\n</pre> class Model(torch.nn.Module):      def __init__(self, n_qubits, n_layers):         super().__init__()         self.n_qubits = n_qubits         self.ansatz1 = ULayerAnsatz(n_qubits, n_layers)         self.embedding = pyq.FeaturemapLayer(n_qubits, pyq.RX)         self.ansatz2 = ULayerAnsatz(n_qubits, n_layers)         self.observable = pyq.Z([0], n_qubits)              def forward(self, x):         batch_size = len(x)         state = self.ansatz1.init_state(batch_size)                  state = self.ansatz1(state)         state = self.embedding(state, x)         state = self.ansatz2(state)                  new_state = self.observable(state)                  state = state.reshape((2**self.n_qubits, batch_size))         new_state = new_state.reshape((2**self.n_qubits, batch_size))         return torch.real(torch.sum(torch.conj(state) * new_state, axis=0)) <p>Let's verify that we are getting reasonable outputs from our untrained QNN</p> In\u00a0[5]: Copied! <pre>n_qubits = 5\nn_layers = 3\nmodel = Model(n_qubits, n_layers)\n\nwith torch.no_grad():\n    y = model(x)\n\nplt.plot(x.numpy(), target_y.numpy(), label=\"truth\")\nplt.plot(x.numpy(), y.numpy(), label=\"initial\")\nplt.legend()\nplt.show()\n</pre> n_qubits = 5 n_layers = 3 model = Model(n_qubits, n_layers)  with torch.no_grad():     y = model(x)  plt.plot(x.numpy(), target_y.numpy(), label=\"truth\") plt.plot(x.numpy(), y.numpy(), label=\"initial\") plt.legend() plt.show() <p>Our QNN is implemented as a <code>torch.nn.Module</code> so we can use the usual <code>torch</code> optimizers to train it.</p> In\u00a0[7]: Copied! <pre>import torch.nn.functional as F\n\noptimizer = torch.optim.Adam(model.parameters(), lr=.01)\nepochs = 200\n\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    y_pred = model(x)\n    loss = F.mse_loss(target_y, y_pred)\n    loss.backward()\n    optimizer.step()\n    print(f\"Epoch {epoch+1:03d} | Loss {loss}\")\n</pre> import torch.nn.functional as F  optimizer = torch.optim.Adam(model.parameters(), lr=.01) epochs = 200  for epoch in range(epochs):     optimizer.zero_grad()     y_pred = model(x)     loss = F.mse_loss(target_y, y_pred)     loss.backward()     optimizer.step()     print(f\"Epoch {epoch+1:03d} | Loss {loss}\") <pre>Epoch 001 | Loss 1.181170973931877e-05\nEpoch 002 | Loss 3.9005150204328295e-05\nEpoch 003 | Loss 0.0005210030244242805\nEpoch 004 | Loss 6.012409726695054e-05\nEpoch 005 | Loss 0.00021009194032554318\nEpoch 006 | Loss 0.0002914833038541067\nEpoch 007 | Loss 0.0001454984851627904\nEpoch 008 | Loss 4.142681408782311e-05\nEpoch 009 | Loss 9.054882419142336e-05\nEpoch 010 | Loss 0.0001531790494452143\nEpoch 011 | Loss 0.00012015653011887463\nEpoch 012 | Loss 5.790713974401939e-05\nEpoch 013 | Loss 3.846728702473956e-05\nEpoch 014 | Loss 5.630471569536954e-05\nEpoch 015 | Loss 7.700979061854381e-05\nEpoch 016 | Loss 7.391532378356758e-05\nEpoch 017 | Loss 4.612078963466576e-05\nEpoch 018 | Loss 2.155939995688723e-05\nEpoch 019 | Loss 2.3721610576853985e-05\nEpoch 020 | Loss 4.3170004830746536e-05\nEpoch 021 | Loss 5.069962559255113e-05\nEpoch 022 | Loss 3.5152058993235534e-05\nEpoch 023 | Loss 1.4055374744605247e-05\nEpoch 024 | Loss 1.023692829664193e-05\nEpoch 025 | Loss 2.4446698606623847e-05\nEpoch 026 | Loss 3.408834997147914e-05\nEpoch 027 | Loss 2.4865126936362327e-05\nEpoch 028 | Loss 9.659374207355973e-06\nEpoch 029 | Loss 6.950788871336306e-06\nEpoch 030 | Loss 1.566768989272486e-05\nEpoch 031 | Loss 2.099277061607817e-05\nEpoch 032 | Loss 1.6212614075325447e-05\nEpoch 033 | Loss 8.235768022404368e-06\nEpoch 034 | Loss 6.009959075292303e-06\nEpoch 035 | Loss 9.772417521725285e-06\nEpoch 036 | Loss 1.2892382127904045e-05\nEpoch 037 | Loss 1.1361810341757317e-05\nEpoch 038 | Loss 7.2561572882857865e-06\nEpoch 039 | Loss 4.821231443489856e-06\nEpoch 040 | Loss 6.128272875842876e-06\nEpoch 041 | Loss 8.843188084005391e-06\nEpoch 042 | Loss 8.675418546268711e-06\nEpoch 043 | Loss 5.450684118847346e-06\nEpoch 044 | Loss 3.5110836783759226e-06\nEpoch 045 | Loss 4.989386678750474e-06\nEpoch 046 | Loss 6.898259805053778e-06\nEpoch 047 | Loss 6.05054456967633e-06\nEpoch 048 | Loss 3.7389955465282206e-06\nEpoch 049 | Loss 3.273212519167249e-06\nEpoch 050 | Loss 4.637559523242552e-06\nEpoch 051 | Loss 5.165131301134411e-06\nEpoch 052 | Loss 4.142896350302605e-06\nEpoch 053 | Loss 3.1492780545134018e-06\nEpoch 054 | Loss 3.233757188669417e-06\nEpoch 055 | Loss 3.86524696418792e-06\nEpoch 056 | Loss 3.953219614950671e-06\nEpoch 057 | Loss 3.312011206526524e-06\nEpoch 058 | Loss 2.7661753462439286e-06\nEpoch 059 | Loss 2.929670133548e-06\nEpoch 060 | Loss 3.3791616358340403e-06\nEpoch 061 | Loss 3.238319199906219e-06\nEpoch 062 | Loss 2.630986577566763e-06\nEpoch 063 | Loss 2.4992796964562005e-06\nEpoch 064 | Loss 2.8735530062625166e-06\nEpoch 065 | Loss 2.938593815700879e-06\nEpoch 066 | Loss 2.5476755194736197e-06\nEpoch 067 | Loss 2.3241505411727017e-06\nEpoch 068 | Loss 2.49713839896336e-06\nEpoch 069 | Loss 2.6112011957839276e-06\nEpoch 070 | Loss 2.4362527269610276e-06\nEpoch 071 | Loss 2.24253269756204e-06\nEpoch 072 | Loss 2.2373816058577022e-06\nEpoch 073 | Loss 2.3310248995766054e-06\nEpoch 074 | Loss 2.3077427496625516e-06\nEpoch 075 | Loss 2.1503126672635597e-06\nEpoch 076 | Loss 2.070910242097326e-06\nEpoch 077 | Loss 2.137149272933625e-06\nEpoch 078 | Loss 2.1596597107860127e-06\nEpoch 079 | Loss 2.0397936834282285e-06\nEpoch 080 | Loss 1.9556617368367096e-06\nEpoch 081 | Loss 1.998179918829005e-06\nEpoch 082 | Loss 2.0117531938650416e-06\nEpoch 083 | Loss 1.93268494654725e-06\nEpoch 084 | Loss 1.8697853805020282e-06\nEpoch 085 | Loss 1.875957033063329e-06\nEpoch 086 | Loss 1.8812430094662359e-06\nEpoch 087 | Loss 1.8393870837550013e-06\nEpoch 088 | Loss 1.787910412014617e-06\nEpoch 089 | Loss 1.7701482382035251e-06\nEpoch 090 | Loss 1.7752261255685842e-06\nEpoch 091 | Loss 1.7504566547702705e-06\nEpoch 092 | Loss 1.7019486718406315e-06\nEpoch 093 | Loss 1.6835082115283767e-06\nEpoch 094 | Loss 1.685667875198429e-06\nEpoch 095 | Loss 1.6616583019769176e-06\nEpoch 096 | Loss 1.6231601566709535e-06\nEpoch 097 | Loss 1.60813362494993e-06\nEpoch 098 | Loss 1.6019701482892067e-06\nEpoch 099 | Loss 1.5803956915397127e-06\nEpoch 100 | Loss 1.5527873527936183e-06\nEpoch 101 | Loss 1.5352883431312178e-06\nEpoch 102 | Loss 1.5252310209689772e-06\nEpoch 103 | Loss 1.5084573236758253e-06\nEpoch 104 | Loss 1.4843679595562227e-06\nEpoch 105 | Loss 1.4667658608496229e-06\nEpoch 106 | Loss 1.457148855226587e-06\nEpoch 107 | Loss 1.4404304018817315e-06\nEpoch 108 | Loss 1.4187656091462116e-06\nEpoch 109 | Loss 1.4045047593157939e-06\nEpoch 110 | Loss 1.3931682693016124e-06\nEpoch 111 | Loss 1.3763410548891802e-06\nEpoch 112 | Loss 1.3585907789414708e-06\nEpoch 113 | Loss 1.3450608769260442e-06\nEpoch 114 | Loss 1.332534011814191e-06\nEpoch 115 | Loss 1.317529909690219e-06\nEpoch 116 | Loss 1.301470982727387e-06\nEpoch 117 | Loss 1.2883992098664887e-06\nEpoch 118 | Loss 1.2764695970430059e-06\nEpoch 119 | Loss 1.2619454042812358e-06\nEpoch 120 | Loss 1.247318667750338e-06\nEpoch 121 | Loss 1.235492552299088e-06\nEpoch 122 | Loss 1.2232337173189462e-06\nEpoch 123 | Loss 1.2094041838489128e-06\nEpoch 124 | Loss 1.196602229533154e-06\nEpoch 125 | Loss 1.185027851699964e-06\nEpoch 126 | Loss 1.1729201462357814e-06\nEpoch 127 | Loss 1.1602693027487138e-06\nEpoch 128 | Loss 1.1482910988692847e-06\nEpoch 129 | Loss 1.1371439541573138e-06\nEpoch 130 | Loss 1.1255718985465116e-06\nEpoch 131 | Loss 1.1136108149941372e-06\nEpoch 132 | Loss 1.1025357900284203e-06\nEpoch 133 | Loss 1.091830958157926e-06\nEpoch 134 | Loss 1.0805734231640713e-06\nEpoch 135 | Loss 1.0695479487719928e-06\nEpoch 136 | Loss 1.059127192210933e-06\nEpoch 137 | Loss 1.0486653310712814e-06\nEpoch 138 | Loss 1.0380690084037267e-06\nEpoch 139 | Loss 1.0277505705549728e-06\nEpoch 140 | Loss 1.0177783820600243e-06\nEpoch 141 | Loss 1.0077843803092286e-06\nEpoch 142 | Loss 9.977294830491515e-07\nEpoch 143 | Loss 9.880084245920512e-07\nEpoch 144 | Loss 9.78507612080833e-07\nEpoch 145 | Loss 9.688991424059435e-07\nEpoch 146 | Loss 9.59433082323173e-07\nEpoch 147 | Loss 9.502412901981052e-07\nEpoch 148 | Loss 9.410977540121816e-07\nEpoch 149 | Loss 9.319727858151028e-07\nEpoch 150 | Loss 9.230320009485983e-07\nEpoch 151 | Loss 9.142515908872536e-07\nEpoch 152 | Loss 9.055176796050045e-07\nEpoch 153 | Loss 8.968476493496918e-07\nEpoch 154 | Loss 8.883585070062157e-07\nEpoch 155 | Loss 8.799798574579335e-07\nEpoch 156 | Loss 8.716306904438497e-07\nEpoch 157 | Loss 8.634115370027542e-07\nEpoch 158 | Loss 8.553286106000076e-07\nEpoch 159 | Loss 8.473066878770816e-07\nEpoch 160 | Loss 8.393611035486784e-07\nEpoch 161 | Loss 8.315383832451852e-07\nEpoch 162 | Loss 8.23812730022084e-07\nEpoch 163 | Loss 8.161585244572439e-07\nEpoch 164 | Loss 8.085853311389707e-07\nEpoch 165 | Loss 8.011311389518617e-07\nEpoch 166 | Loss 7.937509776200442e-07\nEpoch 167 | Loss 7.864414200490334e-07\nEpoch 168 | Loss 7.792321202346505e-07\nEpoch 169 | Loss 7.721129420068149e-07\nEpoch 170 | Loss 7.650566056859965e-07\nEpoch 171 | Loss 7.580867392307161e-07\nEpoch 172 | Loss 7.512019255765706e-07\nEpoch 173 | Loss 7.44392871495942e-07\nEpoch 174 | Loss 7.376554924382388e-07\nEpoch 175 | Loss 7.310041859797791e-07\nEpoch 176 | Loss 7.244223352825202e-07\nEpoch 177 | Loss 7.179107583362865e-07\nEpoch 178 | Loss 7.114729205692211e-07\nEpoch 179 | Loss 7.051138044328317e-07\nEpoch 180 | Loss 6.988167086620162e-07\nEpoch 181 | Loss 6.925921661054752e-07\nEpoch 182 | Loss 6.864380917059668e-07\nEpoch 183 | Loss 6.803475742422391e-07\nEpoch 184 | Loss 6.743241679721031e-07\nEpoch 185 | Loss 6.683699407928609e-07\nEpoch 186 | Loss 6.624817735278676e-07\nEpoch 187 | Loss 6.566483433856844e-07\nEpoch 188 | Loss 6.508865052027779e-07\nEpoch 189 | Loss 6.451858149751575e-07\nEpoch 190 | Loss 6.395429157077213e-07\nEpoch 191 | Loss 6.339613565507968e-07\nEpoch 192 | Loss 6.284421739744305e-07\nEpoch 193 | Loss 6.229794300541488e-07\nEpoch 194 | Loss 6.175748470592854e-07\nEpoch 195 | Loss 6.122284465298443e-07\nEpoch 196 | Loss 6.069336984847245e-07\nEpoch 197 | Loss 6.016991132192018e-07\nEpoch 198 | Loss 5.965180591195436e-07\nEpoch 199 | Loss 5.913902703863853e-07\nEpoch 200 | Loss 5.863220844515445e-07\n</pre> <p>We can verify that the final prediction looks like the target function:</p> In\u00a0[13]: Copied! <pre>with torch.no_grad():\n    y_final = model(x)\n\nplt.plot(x.numpy(), target_y.numpy(), label=\"truth\")\nplt.plot(x.numpy(), y.numpy(), label=\"initial\")\nplt.plot(x.numpy(), y_final.numpy(), \"--\", label=\"final\", linewidth=3)\nplt.legend()\nplt.show()\n</pre> with torch.no_grad():     y_final = model(x)  plt.plot(x.numpy(), target_y.numpy(), label=\"truth\") plt.plot(x.numpy(), y.numpy(), label=\"initial\") plt.plot(x.numpy(), y_final.numpy(), \"--\", label=\"final\", linewidth=3) plt.legend() plt.show()"},{"location":"fit_function/#fitting-a-1d-function","title":"Fitting a 1D function\u00b6","text":""},{"location":"gate_composition/","title":"Arbitrary Gate Composition","text":"In\u00a0[1]: Copied! <pre>from pyqtorch.modules import RX, RY, RZ, U\nfrom torch import pi, Tensor as tensor\n</pre> from pyqtorch.modules import RX, RY, RZ, U from torch import pi, Tensor as tensor In\u00a0[2]: Copied! <pre>gateA = RX(qubits=[0], n_qubits=1)\ngateB = RY(qubits=[0], n_qubits=1)\ngateC = gateA*gateB\n\nprint(gateC)\n</pre> gateA = RX(qubits=[0], n_qubits=1) gateB = RY(qubits=[0], n_qubits=1) gateC = gateA*gateB  print(gateC) <pre>QuantumCircuit(\n  (operations): ModuleList(\n    (0): RX(qubits=[0], n_qubits=1)\n    (1): RY(qubits=[0], n_qubits=1)\n  )\n)\n</pre> In\u00a0[3]: Copied! <pre>def customGate(*args, **kwargs):\n    return RZ(*args, **kwargs) * RY(*args, **kwargs) * RZ(*args, **kwargs)\n\ncirc = customGate(qubits=[0], n_qubits=1)\n\nprint(circ)\n</pre> def customGate(*args, **kwargs):     return RZ(*args, **kwargs) * RY(*args, **kwargs) * RZ(*args, **kwargs)  circ = customGate(qubits=[0], n_qubits=1)  print(circ) <pre>QuantumCircuit(\n  (operations): ModuleList(\n    (0): RZ(qubits=[0], n_qubits=1)\n    (1): RY(qubits=[0], n_qubits=1)\n    (2): RZ(qubits=[0], n_qubits=1)\n  )\n)\n</pre> In\u00a0[4]: Copied! <pre>def customGate(*args, **kwargs):\n    return (RX(*args, **kwargs) * RY(*args, **kwargs)) * (RX(*args, **kwargs) * RZ(*args, **kwargs))\n\ncirc = customGate(qubits=[0], n_qubits=1)\n\nprint(circ)\n</pre> def customGate(*args, **kwargs):     return (RX(*args, **kwargs) * RY(*args, **kwargs)) * (RX(*args, **kwargs) * RZ(*args, **kwargs))  circ = customGate(qubits=[0], n_qubits=1)  print(circ) <pre>QuantumCircuit(\n  (operations): ModuleList(\n    (0): RX(qubits=[0], n_qubits=1)\n    (1): RY(qubits=[0], n_qubits=1)\n    (2): RX(qubits=[0], n_qubits=1)\n    (3): RZ(qubits=[0], n_qubits=1)\n  )\n)\n</pre>"},{"location":"gate_composition/#arbitrary-gate-composition","title":"Arbitrary Gate Composition\u00b6","text":"<p>To create new arbitrary gates, one need only multiply two gates together, as per the following examples.</p>"},{"location":"hamevo/","title":"Hamiltonian Evolution Module Documentation","text":""},{"location":"hamevo/#overview","title":"Overview","text":"<p>The Hamiltonian Evolution (<code>HamiltonianEvolution</code>) module is designed for performing quantum operations using different Hamiltonian evolution strategies, such as 4th order Runge-Kutta (RK4), Eigenvalue Decomposition, and Matrix Exponential.</p> <p>This module also features a function <code>diagonalize()</code> that performs an eigenvalue decomposition on a given Hamiltonian. This function checks if the input Hamiltonian is already diagonal and real before computing the decomposition, thus saving computational resources when the checks are met.</p>"},{"location":"hamevo/#class-definitions","title":"Class Definitions","text":""},{"location":"hamevo/#hamiltonianevolution","title":"<code>HamiltonianEvolution</code>","text":"<p>This class is a PyTorch module designed to encapsulate Hamiltonian Evolution operations. The evolution operation performed by the module depends on the strategy specified through the <code>hamevo_type</code> attribute, which can be a member of the <code>HamEvoType</code> enumeration or an equivalent string (\"RK4\", \"EIG\", \"EXP\"). Default is set to HamEvoEXP.</p>"},{"location":"hamevo/#hamevo","title":"<code>HamEvo</code>","text":"<p>This class is the base class for Hamiltonian evolution operations, which performs the evolution operation using the Runge-Kutta 4 (RK4) numerical method. It provides <code>apply()</code> method that takes a quantum state tensor as an input and applies the Hamiltonian evolution operation. The <code>forward()</code> method provides a simplified interface for applying the operation.</p>"},{"location":"hamevo/#hamevoeig","title":"<code>HamEvoEig</code>","text":"<p>A subclass of <code>HamEvo</code>, this class performs the Hamiltonian evolution operation using the Eigenvalue Decomposition method. In addition to performing the eigenvalue decomposition, it also provides checks if the Hamiltonian is already diagonal, and if so, skips the decomposition computation.</p>"},{"location":"hamevo/#hamevoexp","title":"<code>HamEvoExp</code>","text":"<p>Another subclass of <code>HamEvo</code>, this class performs the Hamiltonian evolution operation using the Matrix Exponential method. For efficiency, it checks if all the Hamiltonians in the batch are diagonal and skips the computation of matrix exponentials if they are.</p>"},{"location":"hamevo/#enum-definitions","title":"Enum Definitions","text":""},{"location":"hamevo/#hamevotype","title":"<code>HamEvoType</code>","text":"<p>An enumeration to represent types of Hamiltonian Evolution, including RK4, Eigenvalue Decomposition, and Exponential. It contains the corresponding classes as the enumeration values.</p>"},{"location":"hamevo/#function-definitions","title":"Function Definitions","text":""},{"location":"hamevo/#diagonalize","title":"<code>diagonalize</code>","text":"<p>A function to diagonalize a Hermitian Hamiltonian, returning eigenvalues and eigenvectors. It also performs checks to see if the Hamiltonian is already diagonal and if it's real to avoid unnecessary computations.</p>"},{"location":"hamevo/#examples","title":"Examples","text":"<p>The following examples show how to use the <code>HamiltonianEvolution</code> module:   Initialization of HamiltonianEvolution takes parameters (qubits, n_qubits, n_steps, hamevo_type)  Using the HamiltonianEvolution instance to evolve the state takes parameters (H, t, state) </p>"},{"location":"hamevo/#example-1","title":"Example 1:","text":"<pre><code>import torch\nimport pyqtorch.modules as pyq\n\n#Define initialization parameters\nn_qubits = 2\nqubits = list(range(n_qubits))\n\n# Define the Hamiltonian H (random for this example)\nH = torch.randn((2**n_qubits, 2**n_qubits), dtype=torch.cdouble)\n\n# Make sure H is Hermitian as required for a Hamiltonian\nH = (H + H.conj().T) / 2\n\n# Define the initial state\nstate = pyq.uniform_state(n_qubits)\n\n# Define the evolution time tensor\nt = torch.tensor([torch.pi / 4], dtype=torch.cdouble)\n\n# Instantiate HamiltonianEvolution with RK4 string input\nhamiltonian_evolution = pyq.HamiltonianEvolution(qubits, n_qubits, 100, \"RK4\")\n\n# Use the HamiltonianEvolution instance to evolve the state\noutput_state_rk4 = hamiltonian_evolution(H, t, state)\n</code></pre>"},{"location":"hamevo/#example-2","title":"Example 2:","text":"<pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Define initialization parameters\nn_qubits = 1\nqubits = list(range(n_qubits))\nn_steps = 100\n\n# Define the Hamiltonian H for a qubit in a z-direction magnetic field\nH = torch.tensor([[0.5, 0], [0, -0.5]], dtype=torch.cdouble)\n\n# Define the initial state as |0&gt; (you could also try with |1&gt; or a superposition state)\nstate = torch.tensor([[1], [0]], dtype=torch.cdouble)\n\n# Define the evolution time tensor\nt = torch.tensor([torch.pi / 2], dtype=torch.cdouble)\n\n# Instantiate HamiltonianEvolution with HamEvoType input\nH_evol = pyq.HamiltonianEvolution(qubits, n_qubits, n_steps, pyq.HamEvoType.EIG)\n\n# Use the HamiltonianEvolution instance to evolve the state\noutput_state_eig = H_evol(H, t, state)\n\n# Print the output state\nprint(output_state_eig)\n\n# Now compare the output state with the expected result: e^(-i * H * t) * |0&gt; = [[e^(-i*t/2)], [0]]\nexpected_state = torch.tensor([[torch.exp(-1j * t / 2)], [0]], dtype=torch.cdouble)\nprint(expected_state)\n\n# Check if the output_state is close to the expected_state\nprint(torch.allclose(output_state_rk4, expected_state))\n</code></pre>"},{"location":"matrices/","title":"Matrices","text":""},{"location":"matrices/#pyqtorch.matrices.NN","title":"<code>NN(N, i=0, j=0, device='cpu')</code>","text":"<p>Returns the tensor representation of the NN interaction operator between qubits i and j in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <code>i</code> <code>int</code> <p>Index of the first qubit (default: 0).</p> <code>0</code> <code>j</code> <code>int</code> <p>Index of the second qubit (default: 0).</p> <code>0</code> <code>device</code> <code>Union[str, device]</code> <p>Device to store the tensor on (default: \"cpu\").</p> <code>'cpu'</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: The tensor representation of the NN interaction operator.</p> <p>Examples: <pre><code>from pyqtorch.matrices import NN\nresult=NN(2, 0, 1)\nprint(result) #tensor([0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j], dtype=torch.complex128)\n</code></pre> <pre><code>tensor([0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j])\n</code></pre></p> Source code in <code>pyqtorch/matrices.py</code> <pre><code>def NN(N: int, i: int = 0, j: int = 0, device: Union[str, torch.device] = \"cpu\") -&gt; torch.Tensor:\n    \"\"\"\n    Returns the tensor representation of the NN interaction operator\n    between qubits i and j in a quantum circuit.\n\n    Arguments:\n        N (int): The total number of qubits in the circuit.\n        i (int): Index of the first qubit (default: 0).\n        j (int): Index of the second qubit (default: 0).\n        device (Union[str, torch.device]): Device to store the tensor on (default: \"cpu\").\n\n    Returns:\n        torch.Tensor: The tensor representation of the NN interaction operator.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from pyqtorch.matrices import NN\n    result=NN(2, 0, 1)\n    print(result) #tensor([0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j], dtype=torch.complex128)\n    ```\n    \"\"\"\n    if i == j:\n        return torch.ones(2**N, dtype=DEFAULT_MATRIX_DTYPE).to(device)\n\n    op_list = [NDIAG.to(device) if k in [i, j] else IDIAG.to(device) for k in range(N)]\n    operator = op_list[0]\n    for op in op_list[1::]:\n        operator = torch.kron(operator, op)\n\n    return operator\n</code></pre>"},{"location":"matrices/#pyqtorch.matrices.ZZ","title":"<code>ZZ(N, i=0, j=0, device='cpu')</code>","text":"<p>Returns the tensor representation of the ZZ interaction operator between qubits i and j in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <code>i</code> <code>int</code> <p>Index of the first qubit (default: 0).</p> <code>0</code> <code>j</code> <code>int</code> <p>Index of the second qubit (default: 0).</p> <code>0</code> <code>device</code> <code>Union[str, device]</code> <p>Device to store the tensor on (default: \"cpu\").</p> <code>'cpu'</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: The tensor representation of the ZZ interaction operator.</p> <p>Examples: <pre><code>from pyqtorch.matrices import ZZ\nresult=ZZ(2, 0, 1)\nprint(result) #tensor([ 1.+0.j, -1.+0.j, -1.+0.j,  1.-0.j], dtype=torch.complex128)\n</code></pre> <pre><code>tensor([ 1.+0.j, -1.+0.j, -1.+0.j,  1.-0.j])\n</code></pre></p> Source code in <code>pyqtorch/matrices.py</code> <pre><code>def ZZ(N: int, i: int = 0, j: int = 0, device: Union[str, torch.device] = \"cpu\") -&gt; torch.Tensor:\n    \"\"\"\n    Returns the tensor representation of the ZZ interaction operator\n    between qubits i and j in a quantum circuit.\n\n    Arguments:\n        N (int): The total number of qubits in the circuit.\n        i (int): Index of the first qubit (default: 0).\n        j (int): Index of the second qubit (default: 0).\n        device (Union[str, torch.device]): Device to store the tensor on (default: \"cpu\").\n\n    Returns:\n        torch.Tensor: The tensor representation of the ZZ interaction operator.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from pyqtorch.matrices import ZZ\n    result=ZZ(2, 0, 1)\n    print(result) #tensor([ 1.+0.j, -1.+0.j, -1.+0.j,  1.-0.j], dtype=torch.complex128)\n    ```\n    \"\"\"\n    if i == j:\n        return torch.ones(2**N).to(device)\n\n    op_list = [ZDIAG.to(device) if k in [i, j] else IDIAG.to(device) for k in range(N)]\n    operator = op_list[0]\n    for op in op_list[1::]:\n        operator = torch.kron(operator, op)\n\n    return operator\n</code></pre>"},{"location":"parametric/","title":"Parametric","text":""},{"location":"parametric/#pyqtorch.modules.parametric.ApplyFn","title":"<code>ApplyFn</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Which function to use to perform matmul between gate and state.</p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class ApplyFn(StrEnum):\n    \"\"\"Which function to use to perform matmul between gate and state.\"\"\"\n\n    VMAP = \"vmap\"\n    EINSUM = \"einsum\"\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CPHASE","title":"<code>CPHASE</code>","text":"<p>             Bases: <code>AbstractGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class CPHASE(AbstractGate):\n    n_params = 1\n\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a controlled-phase (CPHASE) gate in a quantum circuit.\n        The CPhase gate class creates a controlled Phase gate, applying the PhaseGate\n        according to the control qubit state.\n\n        Arguments:\n            qubits (ArrayLike): The control and target qubits for the CPHASE gate.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        \"\"\"\n\n        super().__init__(qubits, n_qubits)\n\n        self.register_buffer(\"imat\", torch.eye(2 ** len(qubits), dtype=DEFAULT_MATRIX_DTYPE))\n        self.apply_fn = APPLY_FN_DICT[apply_fn_type]\n\n    def matrices(self, thetas: torch.Tensor) -&gt; torch.Tensor:\n        theta = thetas.squeeze(0) if thetas.ndim == 2 else thetas\n        batch_size = len(theta)\n        mat = self.imat.repeat((batch_size, 1, 1))\n        mat = torch.permute(mat, (1, 2, 0))\n        phase_rotation_angles = torch.exp(torch.tensor(1j) * theta).unsqueeze(0).unsqueeze(1)\n        mat[-1, -1, :] = phase_rotation_angles\n        return mat\n\n    def apply(self, matrices: torch.Tensor, state: torch.Tensor) -&gt; torch.Tensor:\n        batch_size = matrices.size(-1)\n        return self.apply_fn(state, matrices, self.qubits, self.n_qubits, batch_size)\n\n    def forward(self, state: torch.Tensor, thetas: torch.Tensor) -&gt; torch.Tensor:\n        mats = self.matrices(thetas)\n        return self.apply(mats, state)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CPHASE.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a controlled-phase (CPHASE) gate in a quantum circuit. The CPhase gate class creates a controlled Phase gate, applying the PhaseGate according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The control and target qubits for the CPHASE gate.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a controlled-phase (CPHASE) gate in a quantum circuit.\n    The CPhase gate class creates a controlled Phase gate, applying the PhaseGate\n    according to the control qubit state.\n\n    Arguments:\n        qubits (ArrayLike): The control and target qubits for the CPHASE gate.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    \"\"\"\n\n    super().__init__(qubits, n_qubits)\n\n    self.register_buffer(\"imat\", torch.eye(2 ** len(qubits), dtype=DEFAULT_MATRIX_DTYPE))\n    self.apply_fn = APPLY_FN_DICT[apply_fn_type]\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CRX","title":"<code>CRX</code>","text":"<p>             Bases: <code>ControlledRotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class CRX(ControlledRotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a controlled-X-axis rotation (CRX) gate in a quantum circuit.\n        The CRX gate class creates a controlled RX gate, applying the RX according\n        to the control qubit state.\n\n\n        Arguments:\n            qubits (ArrayLike):The list of qubits the controlled CRX gate acts on.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n        # Create a CRX gate\n        #The CRX gate is a controlled version of the RX gate.\n        #It applies an RX rotation to the target qubit based on the state of the control qubit.\n        #The gate takes two qubits as input: the control qubit and the target qubit.\n\n        crx_gate = pyq.CRX(qubits=[0, 1], n_qubits=2)\n\n        # Create a X gate\n        x_gate=pyq.X(qubits=[0], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        #Apply an X gate to zero state to change its  state from 0 to 1\n        activation_state=x_gate(z_state)\n\n        # Create a random theta angle\n        theta = torch.rand(1)\n\n        # Apply the CRX gate to the activation state with the random theta angle\n        result = crx_gate(activation_state, theta)\n        print(result)\n\n        ```\n        \"\"\"\n        super().__init__(\"X\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CRX.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a controlled-X-axis rotation (CRX) gate in a quantum circuit. The CRX gate class creates a controlled RX gate, applying the RX according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The list of qubits the controlled CRX gate acts on.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n# Create a CRX gate\n#The CRX gate is a controlled version of the RX gate.\n#It applies an RX rotation to the target qubit based on the state of the control qubit.\n#The gate takes two qubits as input: the control qubit and the target qubit.\n\ncrx_gate = pyq.CRX(qubits=[0, 1], n_qubits=2)\n\n# Create a X gate\nx_gate=pyq.X(qubits=[0], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n#Apply an X gate to zero state to change its  state from 0 to 1\nactivation_state=x_gate(z_state)\n\n# Create a random theta angle\ntheta = torch.rand(1)\n\n# Apply the CRX gate to the activation state with the random theta angle\nresult = crx_gate(activation_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[[0.0000+0.0000j],\n         [0.0000+0.0000j]],\n\n        [[0.9533+0.0000j],\n         [0.0000-0.3019j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a controlled-X-axis rotation (CRX) gate in a quantum circuit.\n    The CRX gate class creates a controlled RX gate, applying the RX according\n    to the control qubit state.\n\n\n    Arguments:\n        qubits (ArrayLike):The list of qubits the controlled CRX gate acts on.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n    # Create a CRX gate\n    #The CRX gate is a controlled version of the RX gate.\n    #It applies an RX rotation to the target qubit based on the state of the control qubit.\n    #The gate takes two qubits as input: the control qubit and the target qubit.\n\n    crx_gate = pyq.CRX(qubits=[0, 1], n_qubits=2)\n\n    # Create a X gate\n    x_gate=pyq.X(qubits=[0], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    #Apply an X gate to zero state to change its  state from 0 to 1\n    activation_state=x_gate(z_state)\n\n    # Create a random theta angle\n    theta = torch.rand(1)\n\n    # Apply the CRX gate to the activation state with the random theta angle\n    result = crx_gate(activation_state, theta)\n    print(result)\n\n    ```\n    \"\"\"\n    super().__init__(\"X\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CRY","title":"<code>CRY</code>","text":"<p>             Bases: <code>ControlledRotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class CRY(ControlledRotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a controlled-Y-axis rotation (CRY) gate in a quantum circuit.\n        The CRY gate class creates a controlled RY gate, applying the RY according\n        to the control qubit state.\n\n\n        Arguments:\n            qubits (ArrayLike):The list of qubits the controlled CRY gate acts on.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a CRY gate\n        # The CRY gate is a controlled version of the RY gate.\n        # It applies an RY rotation to the target qubit based on the state of the control qubit.\n        # The gate takes two qubits as input: the control qubit and the target qubit.\n        cry_gate = pyq.CRY(qubits=[0, 1], n_qubits=2)\n\n        # Create a Y gate\n        y_gate = pyq.Y(qubits=[0], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        # Apply a Y gate to the zero state to change its state\n        activation_state = y_gate(z_state)\n\n        # Create a random theta angle\n        theta = torch.rand(1)\n\n        # Apply the CRY gate to the activation state with the random theta angle\n        result = cry_gate(activation_state, theta)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Y\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CRY.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a controlled-Y-axis rotation (CRY) gate in a quantum circuit. The CRY gate class creates a controlled RY gate, applying the RY according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The list of qubits the controlled CRY gate acts on.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a CRY gate\n# The CRY gate is a controlled version of the RY gate.\n# It applies an RY rotation to the target qubit based on the state of the control qubit.\n# The gate takes two qubits as input: the control qubit and the target qubit.\ncry_gate = pyq.CRY(qubits=[0, 1], n_qubits=2)\n\n# Create a Y gate\ny_gate = pyq.Y(qubits=[0], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n# Apply a Y gate to the zero state to change its state\nactivation_state = y_gate(z_state)\n\n# Create a random theta angle\ntheta = torch.rand(1)\n\n# Apply the CRY gate to the activation state with the random theta angle\nresult = cry_gate(activation_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[[0.+0.0000j],\n         [0.+0.0000j]],\n\n        [[0.+0.9999j],\n         [0.+0.0144j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a controlled-Y-axis rotation (CRY) gate in a quantum circuit.\n    The CRY gate class creates a controlled RY gate, applying the RY according\n    to the control qubit state.\n\n\n    Arguments:\n        qubits (ArrayLike):The list of qubits the controlled CRY gate acts on.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a CRY gate\n    # The CRY gate is a controlled version of the RY gate.\n    # It applies an RY rotation to the target qubit based on the state of the control qubit.\n    # The gate takes two qubits as input: the control qubit and the target qubit.\n    cry_gate = pyq.CRY(qubits=[0, 1], n_qubits=2)\n\n    # Create a Y gate\n    y_gate = pyq.Y(qubits=[0], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    # Apply a Y gate to the zero state to change its state\n    activation_state = y_gate(z_state)\n\n    # Create a random theta angle\n    theta = torch.rand(1)\n\n    # Apply the CRY gate to the activation state with the random theta angle\n    result = cry_gate(activation_state, theta)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Y\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CRZ","title":"<code>CRZ</code>","text":"<p>             Bases: <code>ControlledRotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class CRZ(ControlledRotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a controlled-Z-axis rotation (CRZ) gate in a quantum circuit.\n        The CRZ gate class creates a controlled RZ gate, applying the RZ according\n        to the control qubit state.\n\n        Arguments:\n            qubits (ArrayLike):The list of qubits the controlled CRZ gate acts on.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a CRZ gate\n        # The CRZ gate is a controlled version of the RZ gate.\n        # It applies an RZ rotation to the target qubit based on the state of the control qubit.\n        # The gate takes two qubits as input: the control qubit and the target qubit.\n        crz_gate = pyq.CRZ(qubits=[0, 1], n_qubits=2)\n\n        # Create a X gate\n        x_gate = pyq.X(qubits=[0], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        # Apply a X gate to the zero state to change its state\n        activation_state = x_gate(z_state)\n\n        # Create a random theta angle\n        theta = torch.rand(1)\n\n        # Apply the CRZ gate to the activation state with the random theta angle\n        result = crz_gate(activation_state, theta)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Z\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.CRZ.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a controlled-Z-axis rotation (CRZ) gate in a quantum circuit. The CRZ gate class creates a controlled RZ gate, applying the RZ according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The list of qubits the controlled CRZ gate acts on.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a CRZ gate\n# The CRZ gate is a controlled version of the RZ gate.\n# It applies an RZ rotation to the target qubit based on the state of the control qubit.\n# The gate takes two qubits as input: the control qubit and the target qubit.\ncrz_gate = pyq.CRZ(qubits=[0, 1], n_qubits=2)\n\n# Create a X gate\nx_gate = pyq.X(qubits=[0], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n# Apply a X gate to the zero state to change its state\nactivation_state = x_gate(z_state)\n\n# Create a random theta angle\ntheta = torch.rand(1)\n\n# Apply the CRZ gate to the activation state with the random theta angle\nresult = crz_gate(activation_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[[0.0000+0.0000j],\n         [0.0000+0.0000j]],\n\n        [[0.9999-0.0126j],\n         [0.0000+0.0000j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a controlled-Z-axis rotation (CRZ) gate in a quantum circuit.\n    The CRZ gate class creates a controlled RZ gate, applying the RZ according\n    to the control qubit state.\n\n    Arguments:\n        qubits (ArrayLike):The list of qubits the controlled CRZ gate acts on.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a CRZ gate\n    # The CRZ gate is a controlled version of the RZ gate.\n    # It applies an RZ rotation to the target qubit based on the state of the control qubit.\n    # The gate takes two qubits as input: the control qubit and the target qubit.\n    crz_gate = pyq.CRZ(qubits=[0, 1], n_qubits=2)\n\n    # Create a X gate\n    x_gate = pyq.X(qubits=[0], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    # Apply a X gate to the zero state to change its state\n    activation_state = x_gate(z_state)\n\n    # Create a random theta angle\n    theta = torch.rand(1)\n\n    # Apply the CRZ gate to the activation state with the random theta angle\n    result = crz_gate(activation_state, theta)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Z\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.PHASE","title":"<code>PHASE</code>","text":"<p>             Bases: <code>RotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class PHASE(RotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a PHASE rotation gate in a quantum circuit.\n\n        Arguments:\n            qubits (ArrayLike): The qubit index or list of qubit indices.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an PHASE gate\n        gate = pyq.PHASE(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Create a random theta angle\n        theta = torch.rand(1)\n\n        # Apply the PHASE gate to the zero state with the random theta angle\n        result = gate(z_state, theta)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"I\", qubits, n_qubits)\n        self.apply_fn = APPLY_FN_DICT[apply_fn_type]\n\n    def apply(self, matrices: torch.Tensor, state: torch.Tensor) -&gt; torch.Tensor:\n        batch_size = matrices.size(-1)\n        return self.apply_fn(state, matrices, self.qubits, self.n_qubits, batch_size)\n\n    def forward(self, state: torch.Tensor, thetas: torch.Tensor) -&gt; torch.Tensor:\n        mats = self.matrices(thetas)\n        return self.apply(mats, state)\n\n    def matrices(self, thetas: torch.Tensor) -&gt; torch.Tensor:\n        theta = thetas.squeeze(0) if thetas.ndim == 2 else thetas\n        batch_mat = self.imat.unsqueeze(2).repeat(1, 1, len(theta))\n        batch_mat[1, 1, :] = torch.exp(1.0j * thetas).unsqueeze(0).unsqueeze(1)\n        return batch_mat\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.PHASE.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a PHASE rotation gate in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubit index or list of qubit indices.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an PHASE gate\ngate = pyq.PHASE(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Create a random theta angle\ntheta = torch.rand(1)\n\n# Apply the PHASE gate to the zero state with the random theta angle\nresult = gate(z_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[1.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a PHASE rotation gate in a quantum circuit.\n\n    Arguments:\n        qubits (ArrayLike): The qubit index or list of qubit indices.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an PHASE gate\n    gate = pyq.PHASE(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Create a random theta angle\n    theta = torch.rand(1)\n\n    # Apply the PHASE gate to the zero state with the random theta angle\n    result = gate(z_state, theta)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"I\", qubits, n_qubits)\n    self.apply_fn = APPLY_FN_DICT[apply_fn_type]\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.RX","title":"<code>RX</code>","text":"<p>             Bases: <code>RotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class RX(RotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents an X-axis rotation (RX) gate in a quantum circuit.\n        The RX gate class creates a single-qubit RX gate that performs\n        a given rotation around the X axis.\n\n        Arguments:\n            qubits (ArrayLike):The list of qubits the controlled RX gate acts on.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an RX gate\n        rx_gate = pyq.RX(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        #Create a random theta angle\n        theta = torch.rand(1)\n\n        # Every rotational gate accepts a second parameter that is expected to be a Theta angle.\n        # Apply the RX gate to the zero state with your random theta as a second parameter.\n\n        result=rx_gate(z_state, theta)\n        print(result)\n\n        ```\n        \"\"\"\n        super().__init__(\"X\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.RX.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents an X-axis rotation (RX) gate in a quantum circuit. The RX gate class creates a single-qubit RX gate that performs a given rotation around the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The list of qubits the controlled RX gate acts on.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an RX gate\nrx_gate = pyq.RX(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n#Create a random theta angle\ntheta = torch.rand(1)\n\n# Every rotational gate accepts a second parameter that is expected to be a Theta angle.\n# Apply the RX gate to the zero state with your random theta as a second parameter.\n\nresult=rx_gate(z_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[0.9991+0.0000j],\n        [0.0000-0.0413j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents an X-axis rotation (RX) gate in a quantum circuit.\n    The RX gate class creates a single-qubit RX gate that performs\n    a given rotation around the X axis.\n\n    Arguments:\n        qubits (ArrayLike):The list of qubits the controlled RX gate acts on.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an RX gate\n    rx_gate = pyq.RX(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    #Create a random theta angle\n    theta = torch.rand(1)\n\n    # Every rotational gate accepts a second parameter that is expected to be a Theta angle.\n    # Apply the RX gate to the zero state with your random theta as a second parameter.\n\n    result=rx_gate(z_state, theta)\n    print(result)\n\n    ```\n    \"\"\"\n    super().__init__(\"X\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.RY","title":"<code>RY</code>","text":"<p>             Bases: <code>RotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class RY(RotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a Y-axis rotation (RY) gate in a quantum circuit.\n        The RY gate class creates a single-qubit RY gate that performs\n        a given rotation around the Y axis.\n\n        Arguments:\n            qubits (ArrayLike): The qubit index to apply the RY gate to.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an RY gate\n        ry_gate = pyq.RY(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Create a random theta angle\n        theta = torch.rand(1)\n\n        # Apply the RY gate to the zero state with the random theta angle\n        result = ry_gate(z_state, theta)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Y\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.RY.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a Y-axis rotation (RY) gate in a quantum circuit. The RY gate class creates a single-qubit RY gate that performs a given rotation around the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubit index to apply the RY gate to.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an RY gate\nry_gate = pyq.RY(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Create a random theta angle\ntheta = torch.rand(1)\n\n# Apply the RY gate to the zero state with the random theta angle\nresult = ry_gate(z_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[0.9914+0.j],\n        [0.1308+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a Y-axis rotation (RY) gate in a quantum circuit.\n    The RY gate class creates a single-qubit RY gate that performs\n    a given rotation around the Y axis.\n\n    Arguments:\n        qubits (ArrayLike): The qubit index to apply the RY gate to.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an RY gate\n    ry_gate = pyq.RY(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Create a random theta angle\n    theta = torch.rand(1)\n\n    # Apply the RY gate to the zero state with the random theta angle\n    result = ry_gate(z_state, theta)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Y\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.RZ","title":"<code>RZ</code>","text":"<p>             Bases: <code>RotationGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class RZ(RotationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a Z-axis rotation (RZ) gate in a quantum circuit.\n        The RZ gate class creates a single-qubit RZ gate that performs\n        a given rotation around the Z axis.\n\n\n        Arguments:\n            qubits (ArrayLike): The qubit index or list of qubit indices to apply the RZ gate to.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an RZ gate\n        rz_gate = pyq.RZ(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Create a random theta angle\n        theta = torch.rand(1)\n\n        # Apply the RZ gate to the zero state with the random theta angle\n        result = rz_gate(z_state, theta)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Z\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.RZ.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a Z-axis rotation (RZ) gate in a quantum circuit. The RZ gate class creates a single-qubit RZ gate that performs a given rotation around the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubit index or list of qubit indices to apply the RZ gate to.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an RZ gate\nrz_gate = pyq.RZ(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Create a random theta angle\ntheta = torch.rand(1)\n\n# Apply the RZ gate to the zero state with the random theta angle\nresult = rz_gate(z_state, theta)\nprint(result)\n</code></pre> <pre><code>tensor([[0.9877-0.1563j],\n        [0.0000+0.0000j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a Z-axis rotation (RZ) gate in a quantum circuit.\n    The RZ gate class creates a single-qubit RZ gate that performs\n    a given rotation around the Z axis.\n\n\n    Arguments:\n        qubits (ArrayLike): The qubit index or list of qubit indices to apply the RZ gate to.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an RZ gate\n    rz_gate = pyq.RZ(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Create a random theta angle\n    theta = torch.rand(1)\n\n    # Apply the RZ gate to the zero state with the random theta angle\n    result = rz_gate(z_state, theta)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Z\", qubits, n_qubits, apply_fn_type)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class StrEnum(str, Enum):\n    def __str__(self) -&gt; str:\n        \"\"\"Used when dumping enum fields in a schema.\"\"\"\n        ret: str = self.value\n        return ret\n\n    @classmethod\n    def list(cls) -&gt; list[str]:\n        return list(map(lambda c: c.value, cls))  # type: ignore\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.U","title":"<code>U</code>","text":"<p>             Bases: <code>AbstractGate</code></p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>class U(AbstractGate):\n    n_params = 3\n\n    def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n        \"\"\"\n        Represents a parametrized arbitrary rotation along the axes of the Bloch sphere.\n\n        The angles `phi, theta, omega` in tensor format, applied as:\n\n            U(phi, theta, omega) = RZ(omega)RY(theta)RZ(phi)\n\n        Arguments:\n            qubits (ArrayLike): The target qubits for the U gate. It should be a list of qubits.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        \"\"\"\n\n        super().__init__(qubits, n_qubits)\n\n        self.register_buffer(\n            \"a\", torch.tensor([[1, 0], [0, 0]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n        )\n        self.register_buffer(\n            \"b\", torch.tensor([[0, 1], [0, 0]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n        )\n        self.register_buffer(\n            \"c\", torch.tensor([[0, 0], [1, 0]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n        )\n        self.register_buffer(\n            \"d\", torch.tensor([[0, 0], [0, 1]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n        )\n\n    def matrices(self, thetas: torch.Tensor) -&gt; torch.Tensor:\n        if thetas.ndim == 1:\n            thetas = thetas.unsqueeze(1)\n        assert thetas.size(0) == 3\n        phi, theta, omega = thetas[0, :], thetas[1, :], thetas[2, :]\n        batch_size = thetas.size(1)\n\n        t_plus = torch.exp(-1j * (phi + omega) / 2)\n        t_minus = torch.exp(-1j * (phi - omega) / 2)\n        sin_t = torch.sin(theta / 2).unsqueeze(0).unsqueeze(1).repeat((2, 2, 1))\n        cos_t = torch.cos(theta / 2).unsqueeze(0).unsqueeze(1).repeat((2, 2, 1))\n\n        a = self.a.repeat(1, 1, batch_size) * cos_t * t_plus\n        b = self.b.repeat(1, 1, batch_size) * sin_t * torch.conj(t_minus)\n        c = self.c.repeat(1, 1, batch_size) * sin_t * t_minus\n        d = self.d.repeat(1, 1, batch_size) * cos_t * torch.conj(t_plus)\n        return a - b + c + d\n\n    def apply(self, matrices: torch.Tensor, state: torch.Tensor) -&gt; torch.Tensor:\n        batch_size = matrices.size(-1)\n        return _apply_batch_gate(state, matrices, self.qubits, self.n_qubits, batch_size)\n\n    def forward(self, state: torch.Tensor, thetas: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Represents batched state and theta forwarding  to the matrices\n        and apply functions that are part of the U gate implementation\n\n        Arguments:\n            state  (torch.Tensor): batched state\n            thetas (torch.Tensor): Tensor of size 3 ,contains values of `phi`/`theta`/`omega`\n\n        Returns:\n            torch.Tensor: the resulting state after applying the gate\n        \"\"\"\n        mats = self.matrices(thetas)\n        return self.apply(mats, state)\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.U.__init__","title":"<code>__init__(qubits, n_qubits, apply_fn_type=DEFAULT_APPLY_FN)</code>","text":"<p>Represents a parametrized arbitrary rotation along the axes of the Bloch sphere.</p> <p>The angles <code>phi, theta, omega</code> in tensor format, applied as:</p> <pre><code>U(phi, theta, omega) = RZ(omega)RY(theta)RZ(phi)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The target qubits for the U gate. It should be a list of qubits.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int, apply_fn_type: ApplyFn = DEFAULT_APPLY_FN):\n    \"\"\"\n    Represents a parametrized arbitrary rotation along the axes of the Bloch sphere.\n\n    The angles `phi, theta, omega` in tensor format, applied as:\n\n        U(phi, theta, omega) = RZ(omega)RY(theta)RZ(phi)\n\n    Arguments:\n        qubits (ArrayLike): The target qubits for the U gate. It should be a list of qubits.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    \"\"\"\n\n    super().__init__(qubits, n_qubits)\n\n    self.register_buffer(\n        \"a\", torch.tensor([[1, 0], [0, 0]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n    )\n    self.register_buffer(\n        \"b\", torch.tensor([[0, 1], [0, 0]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n    )\n    self.register_buffer(\n        \"c\", torch.tensor([[0, 0], [1, 0]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n    )\n    self.register_buffer(\n        \"d\", torch.tensor([[0, 0], [0, 1]], dtype=DEFAULT_MATRIX_DTYPE).unsqueeze(2)\n    )\n</code></pre>"},{"location":"parametric/#pyqtorch.modules.parametric.U.forward","title":"<code>forward(state, thetas)</code>","text":"<p>Represents batched state and theta forwarding  to the matrices and apply functions that are part of the U gate implementation</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code> (torch.Tensor</code> <p>batched state</p> required <code>thetas</code> <code>Tensor</code> <p>Tensor of size 3 ,contains values of <code>phi</code>/<code>theta</code>/<code>omega</code></p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: the resulting state after applying the gate</p> Source code in <code>pyqtorch/modules/parametric.py</code> <pre><code>def forward(self, state: torch.Tensor, thetas: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Represents batched state and theta forwarding  to the matrices\n    and apply functions that are part of the U gate implementation\n\n    Arguments:\n        state  (torch.Tensor): batched state\n        thetas (torch.Tensor): Tensor of size 3 ,contains values of `phi`/`theta`/`omega`\n\n    Returns:\n        torch.Tensor: the resulting state after applying the gate\n    \"\"\"\n    mats = self.matrices(thetas)\n    return self.apply(mats, state)\n</code></pre>"},{"location":"primitive/","title":"Primitive","text":""},{"location":"primitive/#pyqtorch.modules.primitive.CNOT","title":"<code>CNOT</code>","text":"<p>             Bases: <code>ControlledOperationGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class CNOT(ControlledOperationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a controlled NOT (CNOT) gate in a quantum circuit.\n\n        Arguments:\n            qubits (ArrayLike): The control and target qubits for the CNOT gate.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a CNOT gate\n        cnot_gate = pyq.CNOT(qubits=[0, 1], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        # Apply the CNOT gate to the zero state\n        result = cnot_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"X\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CNOT.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a controlled NOT (CNOT) gate in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The control and target qubits for the CNOT gate.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a CNOT gate\ncnot_gate = pyq.CNOT(qubits=[0, 1], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n# Apply the CNOT gate to the zero state\nresult = cnot_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[[1.+0.j],\n         [0.+0.j]],\n\n        [[0.+0.j],\n         [0.+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a controlled NOT (CNOT) gate in a quantum circuit.\n\n    Arguments:\n        qubits (ArrayLike): The control and target qubits for the CNOT gate.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a CNOT gate\n    cnot_gate = pyq.CNOT(qubits=[0, 1], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    # Apply the CNOT gate to the zero state\n    result = cnot_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"X\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CSWAP","title":"<code>CSWAP</code>","text":"<p>             Bases: <code>ControlledOperationGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class CSWAP(ControlledOperationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a controlled-SWAP (CSWAP) gate in a quantum circuit.\n        The CSWAP gate class creates a controlled SWAP gate, applying\n        the SWAP gate according to the control qubit state.\n\n\n        Arguments:\n            qubits (ArrayLike): The control and targets qubits for the CSWAP gate.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a CSWAP gate\n        cswap_gate = pyq.CSWAP(qubits=[0, 1, 2], n_qubits=3)\n\n        # Create a zero state\n        swap_state = pyq.zero_state(n_qubits=3)\n\n        # Apply the CSWAP gate to the zero state\n        result = cswap_gate(swap_state)\n        print(result)\n        \"\"\"\n        super().__init__(\"SWAP\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CSWAP.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a controlled-SWAP (CSWAP) gate in a quantum circuit. The CSWAP gate class creates a controlled SWAP gate, applying the SWAP gate according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The control and targets qubits for the CSWAP gate.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: ```python exec=\"on\" source=\"above\" result=\"json\" import torch import pyqtorch.modules as pyq</p>"},{"location":"primitive/#pyqtorch.modules.primitive.CSWAP.__init__--create-a-cswap-gate","title":"Create a CSWAP gate","text":"<p>cswap_gate = pyq.CSWAP(qubits=[0, 1, 2], n_qubits=3)</p>"},{"location":"primitive/#pyqtorch.modules.primitive.CSWAP.__init__--create-a-zero-state","title":"Create a zero state","text":"<p>swap_state = pyq.zero_state(n_qubits=3)</p>"},{"location":"primitive/#pyqtorch.modules.primitive.CSWAP.__init__--apply-the-cswap-gate-to-the-zero-state","title":"Apply the CSWAP gate to the zero state","text":"<p>result = cswap_gate(swap_state) print(result)</p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a controlled-SWAP (CSWAP) gate in a quantum circuit.\n    The CSWAP gate class creates a controlled SWAP gate, applying\n    the SWAP gate according to the control qubit state.\n\n\n    Arguments:\n        qubits (ArrayLike): The control and targets qubits for the CSWAP gate.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a CSWAP gate\n    cswap_gate = pyq.CSWAP(qubits=[0, 1, 2], n_qubits=3)\n\n    # Create a zero state\n    swap_state = pyq.zero_state(n_qubits=3)\n\n    # Apply the CSWAP gate to the zero state\n    result = cswap_gate(swap_state)\n    print(result)\n    \"\"\"\n    super().__init__(\"SWAP\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CY","title":"<code>CY</code>","text":"<p>             Bases: <code>ControlledOperationGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class CY(ControlledOperationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a controlled-Y (CY) gate in a quantum circuit.\n        The CY Gate class creates a controlled Y gate, applying the Y gate\n        according to the control qubit state.\n\n        Arguments:\n            qubits (ArrayLike): The control and target qubits for the CY gate.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a CY gate\n        cy_gate = pyq.CY(qubits=[0, 1], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        # Apply the CY gate to the zero state\n        result = cy_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Y\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CY.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a controlled-Y (CY) gate in a quantum circuit. The CY Gate class creates a controlled Y gate, applying the Y gate according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The control and target qubits for the CY gate.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a CY gate\ncy_gate = pyq.CY(qubits=[0, 1], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n# Apply the CY gate to the zero state\nresult = cy_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[[1.+0.j],\n         [0.+0.j]],\n\n        [[0.+0.j],\n         [0.+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a controlled-Y (CY) gate in a quantum circuit.\n    The CY Gate class creates a controlled Y gate, applying the Y gate\n    according to the control qubit state.\n\n    Arguments:\n        qubits (ArrayLike): The control and target qubits for the CY gate.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a CY gate\n    cy_gate = pyq.CY(qubits=[0, 1], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    # Apply the CY gate to the zero state\n    result = cy_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Y\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CZ","title":"<code>CZ</code>","text":"<p>             Bases: <code>ControlledOperationGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class CZ(ControlledOperationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a controlled-Z (CZ) gate in a quantum circuit.\n        The CZ gate class creates a controlled Z gate, applying\n        the Z gate according to the control qubit state.\n\n\n        Arguments:\n            qubits (ArrayLike): The control and target qubits for the CZ gate.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a CZ gate\n        cz_gate = pyq.CZ(qubits=[0, 1], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        # Apply the CZ gate to the zero state\n        result = cz_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Z\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.CZ.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a controlled-Z (CZ) gate in a quantum circuit. The CZ gate class creates a controlled Z gate, applying the Z gate according to the control qubit state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The control and target qubits for the CZ gate.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a CZ gate\ncz_gate = pyq.CZ(qubits=[0, 1], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n# Apply the CZ gate to the zero state\nresult = cz_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[[1.+0.j],\n         [0.+0.j]],\n\n        [[0.+0.j],\n         [0.+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a controlled-Z (CZ) gate in a quantum circuit.\n    The CZ gate class creates a controlled Z gate, applying\n    the Z gate according to the control qubit state.\n\n\n    Arguments:\n        qubits (ArrayLike): The control and target qubits for the CZ gate.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a CZ gate\n    cz_gate = pyq.CZ(qubits=[0, 1], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    # Apply the CZ gate to the zero state\n    result = cz_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Z\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.H","title":"<code>H</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class H(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents an H gate (Hadamard gate) in a quantum circuit.\n        The H Gate class creates a H gate. It performs a PI rotation\n        around the X+Z axis changing the basis from |0\u27e9,|1\u27e9 to  |+\u27e9,|-\u27e9\n        and from |+\u27e9,|-\u27e9 back to |0\u27e9,|1\u27e9  depending on the number of times\n        the gate is applied\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the H gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an H gate\n        h_gate = pyq.H(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the H gate to the zero state\n        result = h_gate(z_state)\n        print(result)  # tensor([[0.7071+0.j],[0.7071+0.j]], dtype=torch.complex128)\n        ```\n        \"\"\"\n        super().__init__(\"H\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.H.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents an H gate (Hadamard gate) in a quantum circuit. The H Gate class creates a H gate. It performs a PI rotation around the X+Z axis changing the basis from |0\u27e9,|1\u27e9 to  |+\u27e9,|-\u27e9 and from |+\u27e9,|-\u27e9 back to |0\u27e9,|1\u27e9  depending on the number of times the gate is applied</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the H gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an H gate\nh_gate = pyq.H(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the H gate to the zero state\nresult = h_gate(z_state)\nprint(result)  # tensor([[0.7071+0.j],[0.7071+0.j]], dtype=torch.complex128)\n</code></pre> <pre><code>tensor([[0.7071+0.j],\n        [0.7071+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents an H gate (Hadamard gate) in a quantum circuit.\n    The H Gate class creates a H gate. It performs a PI rotation\n    around the X+Z axis changing the basis from |0\u27e9,|1\u27e9 to  |+\u27e9,|-\u27e9\n    and from |+\u27e9,|-\u27e9 back to |0\u27e9,|1\u27e9  depending on the number of times\n    the gate is applied\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the H gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an H gate\n    h_gate = pyq.H(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the H gate to the zero state\n    result = h_gate(z_state)\n    print(result)  # tensor([[0.7071+0.j],[0.7071+0.j]], dtype=torch.complex128)\n    ```\n    \"\"\"\n    super().__init__(\"H\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.I","title":"<code>I</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class I(PrimitiveGate):  # noqa: E742\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents an I gate (identity gate) in a quantum circuit.\n        The I gate class creates a I gate, which has no effect on the state of a qubit.\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the I gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an I gate\n        i_gate = pyq.I(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the I gate to the zero state\n        result = i_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"I\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.I.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents an I gate (identity gate) in a quantum circuit. The I gate class creates a I gate, which has no effect on the state of a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the I gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an I gate\ni_gate = pyq.I(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the I gate to the zero state\nresult = i_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[1.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents an I gate (identity gate) in a quantum circuit.\n    The I gate class creates a I gate, which has no effect on the state of a qubit.\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the I gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an I gate\n    i_gate = pyq.I(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the I gate to the zero state\n    result = i_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"I\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.N","title":"<code>N</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class N(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents an N gate ((I-Z)/2 projector gate) in a quantum circuit.\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the S gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an N gate\n        n_gate = pyq.N(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        n_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the N gate to the zero state\n        result = n_gate(n_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"N\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.N.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents an N gate ((I-Z)/2 projector gate) in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the S gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an N gate\nn_gate = pyq.N(qubits=[0], n_qubits=1)\n\n# Create a zero state\nn_state = pyq.zero_state(n_qubits=1)\n\n# Apply the N gate to the zero state\nresult = n_gate(n_state)\nprint(result)\n</code></pre> <pre><code>tensor([[0.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents an N gate ((I-Z)/2 projector gate) in a quantum circuit.\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the S gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an N gate\n    n_gate = pyq.N(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    n_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the N gate to the zero state\n    result = n_gate(n_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"N\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.S","title":"<code>S</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class S(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents an S gate (PI/2 phase gate) in a quantum circuit.\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the S gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an S gate\n        s_gate = pyq.S(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the S gate to the zero state\n        result = s_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"S\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.S.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents an S gate (PI/2 phase gate) in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the S gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an S gate\ns_gate = pyq.S(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the S gate to the zero state\nresult = s_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[1.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents an S gate (PI/2 phase gate) in a quantum circuit.\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the S gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an S gate\n    s_gate = pyq.S(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the S gate to the zero state\n    result = s_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"S\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.SDagger","title":"<code>SDagger</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class SDagger(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents an SDagger gate (-PI/2 phase gate) in a quantum circuit.\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the S gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an SDagger gate\n        sdagger_gate = pyq.SDagger(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the SDagger gate to the zero state\n        result = sdagger_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"SDAGGER\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.SDagger.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents an SDagger gate (-PI/2 phase gate) in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the S gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an SDagger gate\nsdagger_gate = pyq.SDagger(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the SDagger gate to the zero state\nresult = sdagger_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[1.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents an SDagger gate (-PI/2 phase gate) in a quantum circuit.\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the S gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an SDagger gate\n    sdagger_gate = pyq.SDagger(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the SDagger gate to the zero state\n    result = sdagger_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"SDAGGER\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.SWAP","title":"<code>SWAP</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class SWAP(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a SWAP gate in a quantum circuit.\n        The SwapGate swaps the qubit states of two quantum wires.\n\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the SWAP gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a SWAP gate\n        swap_gate = pyq.SWAP(qubits=[0, 1], n_qubits=2)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=2)\n\n        # Apply the SWAP gate to the zero state\n        result = swap_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"SWAP\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.SWAP.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a SWAP gate in a quantum circuit. The SwapGate swaps the qubit states of two quantum wires.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the SWAP gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a SWAP gate\nswap_gate = pyq.SWAP(qubits=[0, 1], n_qubits=2)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=2)\n\n# Apply the SWAP gate to the zero state\nresult = swap_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[[1.+0.j],\n         [0.+0.j]],\n\n        [[0.+0.j],\n         [0.+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a SWAP gate in a quantum circuit.\n    The SwapGate swaps the qubit states of two quantum wires.\n\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the SWAP gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a SWAP gate\n    swap_gate = pyq.SWAP(qubits=[0, 1], n_qubits=2)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=2)\n\n    # Apply the SWAP gate to the zero state\n    result = swap_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"SWAP\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.T","title":"<code>T</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class T(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a T gate (PI/4 phase gate) in a quantum circuit.\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the T gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a T gate\n        t_gate = pyq.T(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the T gate to the zero state\n        result = t_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"T\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.T.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a T gate (PI/4 phase gate) in a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the T gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a T gate\nt_gate = pyq.T(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the T gate to the zero state\nresult = t_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[1.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a T gate (PI/4 phase gate) in a quantum circuit.\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the T gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a T gate\n    t_gate = pyq.T(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the T gate to the zero state\n    result = t_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"T\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.Toffoli","title":"<code>Toffoli</code>","text":"<p>             Bases: <code>ControlledOperationGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class Toffoli(ControlledOperationGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a multi qubit controlled toffoli gate in a quantum circuit.\n        This gate performs a NOT operation only if all the control qubits are in state 1.\n        Arguments:\n            qubits (ArrayLike): The first n-1 qubits will be considered as the control\n                                qubits and the last one will be the target qubit of the\n                                Toffoli gate.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a Toffoli gate with 2 control qubits.\n        toffoli_gate = pyq.Toffoli(qubits=[0, 1, 2], n_qubits=3)\n\n        # Create a one state\n        state_1111 = pyq.X(qubits=[0], n_qubits=3)(pyq.X(qubits=[1], n_qubits=3)\n        (pyq.X(qubits=[2], n_qubits=3)(pyq.zero_state(n_qubits=3)))\n\n        # Apply the Toffoli gate to the zero state\n        result = toffoli_gate(toffoli_state)\n        print(result)\n        \"\"\"\n        super().__init__(\"X\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.Toffoli.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a multi qubit controlled toffoli gate in a quantum circuit. This gate performs a NOT operation only if all the control qubits are in state 1. Arguments:     qubits (ArrayLike): The first n-1 qubits will be considered as the control                         qubits and the last one will be the target qubit of the                         Toffoli gate.</p> <p>Examples: ```python exec=\"on\" source=\"above\" result=\"json\" import torch import pyqtorch.modules as pyq</p>"},{"location":"primitive/#pyqtorch.modules.primitive.Toffoli.__init__--create-a-toffoli-gate-with-2-control-qubits","title":"Create a Toffoli gate with 2 control qubits.","text":"<p>toffoli_gate = pyq.Toffoli(qubits=[0, 1, 2], n_qubits=3)</p>"},{"location":"primitive/#pyqtorch.modules.primitive.Toffoli.__init__--create-a-one-state","title":"Create a one state","text":"<p>state_1111 = pyq.X(qubits=[0], n_qubits=3)(pyq.X(qubits=[1], n_qubits=3) (pyq.X(qubits=[2], n_qubits=3)(pyq.zero_state(n_qubits=3)))</p>"},{"location":"primitive/#pyqtorch.modules.primitive.Toffoli.__init__--apply-the-toffoli-gate-to-the-zero-state","title":"Apply the Toffoli gate to the zero state","text":"<p>result = toffoli_gate(toffoli_state) print(result)</p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a multi qubit controlled toffoli gate in a quantum circuit.\n    This gate performs a NOT operation only if all the control qubits are in state 1.\n    Arguments:\n        qubits (ArrayLike): The first n-1 qubits will be considered as the control\n                            qubits and the last one will be the target qubit of the\n                            Toffoli gate.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a Toffoli gate with 2 control qubits.\n    toffoli_gate = pyq.Toffoli(qubits=[0, 1, 2], n_qubits=3)\n\n    # Create a one state\n    state_1111 = pyq.X(qubits=[0], n_qubits=3)(pyq.X(qubits=[1], n_qubits=3)\n    (pyq.X(qubits=[2], n_qubits=3)(pyq.zero_state(n_qubits=3)))\n\n    # Apply the Toffoli gate to the zero state\n    result = toffoli_gate(toffoli_state)\n    print(result)\n    \"\"\"\n    super().__init__(\"X\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.X","title":"<code>X</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class X(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents an X gate (Pauli-X gate) in a quantum circuit.\n        The X gate class creates a  X gate that performs a PI rotation around the X axis\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the X gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create an X gate\n        x_gate = pyq.X(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the X gate to the zero state\n        result = x_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"X\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.X.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents an X gate (Pauli-X gate) in a quantum circuit. The X gate class creates a  X gate that performs a PI rotation around the X axis</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the X gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create an X gate\nx_gate = pyq.X(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the X gate to the zero state\nresult = x_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[0.+0.j],\n        [1.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents an X gate (Pauli-X gate) in a quantum circuit.\n    The X gate class creates a  X gate that performs a PI rotation around the X axis\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the X gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create an X gate\n    x_gate = pyq.X(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the X gate to the zero state\n    result = x_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"X\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.Y","title":"<code>Y</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class Y(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a Y gate (Pauli-Y gate) in a quantum circuit.\n        The Y gate class creates a  Y gate that performs a PI rotation around the Y axis.\n\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the Y gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a Y gate\n        y_gate = pyq.Y(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the Y gate to the zero state\n        result = y_gate(z_state)\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Y\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.Y.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a Y gate (Pauli-Y gate) in a quantum circuit. The Y gate class creates a  Y gate that performs a PI rotation around the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the Y gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a Y gate\ny_gate = pyq.Y(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the Y gate to the zero state\nresult = y_gate(z_state)\nprint(result)\n</code></pre> <pre><code>tensor([[0.+0.j],\n        [0.+1.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a Y gate (Pauli-Y gate) in a quantum circuit.\n    The Y gate class creates a  Y gate that performs a PI rotation around the Y axis.\n\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the Y gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a Y gate\n    y_gate = pyq.Y(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the Y gate to the zero state\n    result = y_gate(z_state)\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Y\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.Z","title":"<code>Z</code>","text":"<p>             Bases: <code>PrimitiveGate</code></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>class Z(PrimitiveGate):\n    def __init__(self, qubits: ArrayLike, n_qubits: int):\n        \"\"\"\n        Represents a Z gate (Pauli-Z gate) in a quantum circuit.\n        The ZGate class creates a Z gate that performs a PI rotation around the Z axis.\n\n        Arguments:\n            qubits (ArrayLike): The qubits to which the Z gate is applied.\n            n_qubits (int): The total number of qubits in the circuit.\n\n        Examples:\n        ```python exec=\"on\" source=\"above\" result=\"json\"\n        import torch\n        import pyqtorch.modules as pyq\n\n        # Create a Z gate\n        z_gate = pyq.Z(qubits=[0], n_qubits=1)\n\n        # Create a zero state\n        z_state = pyq.zero_state(n_qubits=1)\n\n        # Apply the Z gate to the zero state\n        result = z_gate(z_state)\n\n        print(result)\n        ```\n        \"\"\"\n        super().__init__(\"Z\", qubits, n_qubits)\n</code></pre>"},{"location":"primitive/#pyqtorch.modules.primitive.Z.__init__","title":"<code>__init__(qubits, n_qubits)</code>","text":"<p>Represents a Z gate (Pauli-Z gate) in a quantum circuit. The ZGate class creates a Z gate that performs a PI rotation around the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>ArrayLike</code> <p>The qubits to which the Z gate is applied.</p> required <code>n_qubits</code> <code>int</code> <p>The total number of qubits in the circuit.</p> required <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\n# Create a Z gate\nz_gate = pyq.Z(qubits=[0], n_qubits=1)\n\n# Create a zero state\nz_state = pyq.zero_state(n_qubits=1)\n\n# Apply the Z gate to the zero state\nresult = z_gate(z_state)\n\nprint(result)\n</code></pre> <pre><code>tensor([[1.+0.j],\n        [0.+0.j]])\n</code></pre></p> Source code in <code>pyqtorch/modules/primitive.py</code> <pre><code>def __init__(self, qubits: ArrayLike, n_qubits: int):\n    \"\"\"\n    Represents a Z gate (Pauli-Z gate) in a quantum circuit.\n    The ZGate class creates a Z gate that performs a PI rotation around the Z axis.\n\n    Arguments:\n        qubits (ArrayLike): The qubits to which the Z gate is applied.\n        n_qubits (int): The total number of qubits in the circuit.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    # Create a Z gate\n    z_gate = pyq.Z(qubits=[0], n_qubits=1)\n\n    # Create a zero state\n    z_state = pyq.zero_state(n_qubits=1)\n\n    # Apply the Z gate to the zero state\n    result = z_gate(z_state)\n\n    print(result)\n    ```\n    \"\"\"\n    super().__init__(\"Z\", qubits, n_qubits)\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#pyqtorch.modules.utils.invert_endianness","title":"<code>invert_endianness(wf)</code>","text":"<p>Inverts the endianness of a wave function.</p> <p>Parameters:</p> Name Type Description Default <code>wf</code> <code>Tensor</code> <p>the target wf as a torch Tensor of shape batch_size X 2**n_qubits</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The inverted wave function.</p> Source code in <code>pyqtorch/modules/utils.py</code> <pre><code>def invert_endianness(wf: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Inverts the endianness of a wave function.\n\n    Args:\n        wf (Tensor): the target wf as a torch Tensor of shape batch_size X 2**n_qubits\n\n    Returns:\n        The inverted wave function.\n    \"\"\"\n    try:\n        wf = flatten_wf(wf)\n    except RuntimeError:\n        wf = wf\n    n_qubits = int(log2(wf.shape[1]))\n    ls = list(range(2**n_qubits))\n    permute_ind = torch.tensor([int(f\"{num:0{n_qubits}b}\"[::-1], 2) for num in ls])\n    return wf[:, permute_ind]\n</code></pre>"},{"location":"utils/#pyqtorch.modules.utils.is_diag","title":"<code>is_diag(H)</code>","text":"<p>Returns True if Hamiltonian H is diagonal.</p> Source code in <code>pyqtorch/modules/utils.py</code> <pre><code>def is_diag(H: torch.Tensor) -&gt; bool:\n    \"\"\"\n    Returns True if Hamiltonian H is diagonal.\n    \"\"\"\n    return len(torch.abs(torch.triu(H, diagonal=1)).to_sparse().coalesce().values()) == 0\n</code></pre>"},{"location":"utils/#pyqtorch.modules.utils.is_real","title":"<code>is_real(H)</code>","text":"<p>Returns True if Hamiltonian H is real.</p> Source code in <code>pyqtorch/modules/utils.py</code> <pre><code>def is_real(H: torch.Tensor) -&gt; bool:\n    \"\"\"\n    Returns True if Hamiltonian H is real.\n    \"\"\"\n    return len(torch.imag(H).to_sparse().coalesce().values()) == 0\n</code></pre>"},{"location":"utils/#pyqtorch.modules.utils.rot_matrices","title":"<code>rot_matrices(theta, P, I, batch_size)</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: a batch of gates after applying theta</p> Source code in <code>pyqtorch/modules/utils.py</code> <pre><code>def rot_matrices(\n    theta: torch.Tensor, P: torch.Tensor, I: torch.Tensor, batch_size: int  # noqa: E741\n) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor: a batch of gates after applying theta\n    \"\"\"\n    cos_t = torch.cos(theta / 2).unsqueeze(0).unsqueeze(1)\n    cos_t = cos_t.repeat((2, 2, 1))\n    sin_t = torch.sin(theta / 2).unsqueeze(0).unsqueeze(1)\n    sin_t = sin_t.repeat((2, 2, 1))\n\n    batch_imat = I.unsqueeze(2).repeat(1, 1, batch_size)\n    batch_operation_mat = P.unsqueeze(2).repeat(1, 1, batch_size)\n\n    return cos_t * batch_imat - 1j * sin_t * batch_operation_mat\n</code></pre>"},{"location":"utils/#pyqtorch.modules.utils.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1, device='cpu', dtype=DEFAULT_MATRIX_DTYPE)</code>","text":"<p>Generates the uniform state for a specified number of qubits. Returns a tensor representing the uniform state. The shape of the tensor is (2^n_qubits, batch_size), where 2^n_qubits is the total number of possible states for the given number of qubits. The data type of the tensor is specified by the dtype parameter. Each element of the tensor is initialized to 1/sqrt(2^n_qubits), ensuring that the total probability of the state is equal to 1.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits for which the uniform state is to be generated.</p> required <code>batch_size</code> <code>int</code> <p>The batch size for the uniform state.</p> <code>1</code> <code>device</code> <code>str</code> <p>The device on which the uniform state tensor is to be allocated.</p> <code>'cpu'</code> <code>dtype</code> <code>DEFAULT_MATRIX_DTYPE</code> <p>The data type of the uniform state tensor.</p> <code>DEFAULT_MATRIX_DTYPE</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: A tensor representing the uniform state.</p> <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\nstate = pyq.uniform_state(n_qubits=2)\nprint(state)\n#tensor([[[0.5000+0.j],[0.5000+0.j]],[[0.5000+0.j],[0.5000+0.j]]], dtype=torch.complex128)\n</code></pre> <pre><code>tensor([[[0.5000+0.j],\n         [0.5000+0.j]],\n\n        [[0.5000+0.j],\n         [0.5000+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/utils.py</code> <pre><code>def uniform_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    device: str | torch.device = \"cpu\",\n    dtype: torch.dtype = DEFAULT_MATRIX_DTYPE,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Returns a tensor representing the uniform state.\n    The shape of the tensor is (2^n_qubits, batch_size),\n    where 2^n_qubits is the total number of possible states for the given number of qubits.\n    The data type of the tensor is specified by the dtype parameter.\n    Each element of the tensor is initialized to 1/sqrt(2^n_qubits),\n    ensuring that the total probability of the state is equal to 1.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the uniform state is to be generated.\n        batch_size (int): The batch size for the uniform state.\n        device (str): The device on which the uniform state tensor is to be allocated.\n        dtype (DEFAULT_MATRIX_DTYPE): The data type of the uniform state tensor.\n\n    Returns:\n        torch.Tensor: A tensor representing the uniform state.\n\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    state = pyq.uniform_state(n_qubits=2)\n    print(state)\n    #tensor([[[0.5000+0.j],[0.5000+0.j]],[[0.5000+0.j],[0.5000+0.j]]], dtype=torch.complex128)\n    ```\n    \"\"\"\n    state = torch.ones((2**n_qubits, batch_size), dtype=dtype, device=device)\n    state = state / torch.sqrt(torch.tensor(2**n_qubits))\n    state = state.reshape([2] * n_qubits + [batch_size])\n    return state\n</code></pre>"},{"location":"utils/#pyqtorch.modules.utils.zero_state","title":"<code>zero_state(n_qubits, batch_size=1, device='cpu', dtype=DEFAULT_MATRIX_DTYPE)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits for which the zero state is to be generated.</p> required <code>batch_size</code> <code>int</code> <p>The batch size for the zero state.</p> <code>1</code> <code>device</code> <code>str</code> <p>The device on which the zero state tensor is to be allocated eg cpu or gpu.</p> <code>'cpu'</code> <code>dtype</code> <code>DEFAULT_MATRIX_DTYPE</code> <p>The data type of the zero state tensor.</p> <code>DEFAULT_MATRIX_DTYPE</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: A tensor representing the zero state.</p> <code>Tensor</code> <p>The shape of the tensor is (batch_size, 2^n_qubits),</p> <code>Tensor</code> <p>where 2^n_qubits is the total number of possible states for the given number of qubits.</p> <code>Tensor</code> <p>The data type of the tensor is specified by the dtype parameter.</p> <p>Examples: <pre><code>import torch\nimport pyqtorch.modules as pyq\n\nstate = pyq.zero_state(n_qubits=2)\nprint(state)  #tensor([[[1.+0.j],[0.+0.j]],[[0.+0.j],[0.+0.j]]], dtype=torch.complex128)\n</code></pre> <pre><code>tensor([[[1.+0.j],\n         [0.+0.j]],\n\n        [[0.+0.j],\n         [0.+0.j]]])\n</code></pre></p> Source code in <code>pyqtorch/modules/utils.py</code> <pre><code>def zero_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    device: str | torch.device = \"cpu\",\n    dtype: torch.dtype = DEFAULT_MATRIX_DTYPE,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n        device (str): The device on which the zero state tensor is to be allocated eg cpu or gpu.\n        dtype (DEFAULT_MATRIX_DTYPE): The data type of the zero state tensor.\n\n    Returns:\n        torch.Tensor: A tensor representing the zero state.\n        The shape of the tensor is (batch_size, 2^n_qubits),\n        where 2^n_qubits is the total number of possible states for the given number of qubits.\n        The data type of the tensor is specified by the dtype parameter.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    import pyqtorch.modules as pyq\n\n    state = pyq.zero_state(n_qubits=2)\n    print(state)  #tensor([[[1.+0.j],[0.+0.j]],[[0.+0.j],[0.+0.j]]], dtype=torch.complex128)\n    ```\n    \"\"\"\n    state = torch.zeros((2**n_qubits, batch_size), dtype=dtype, device=device)\n    state[0] = 1\n    state = state.reshape([2] * n_qubits + [batch_size])\n    return state\n</code></pre>"},{"location":"deprecated/QAOA/","title":"QAOA","text":"In\u00a0[23]: Copied! <pre>import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.nn.init as init\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nfrom pyqtorch.core.circuit import QuantumCircuit\nfrom pyqtorch.ansatz import AlternateLayerAnsatz\nfrom pyqtorch.embedding import SingleLayerEncoding\nfrom pyqtorch.core.operation import Z, RX\n</pre> import torch import torch.nn as nn import torch.nn.functional as F import torch.nn.init as init  import numpy as np import matplotlib.pyplot as plt import networkx as nx  from pyqtorch.core.circuit import QuantumCircuit from pyqtorch.ansatz import AlternateLayerAnsatz from pyqtorch.embedding import SingleLayerEncoding from pyqtorch.core.operation import Z, RX In\u00a0[24]: Copied! <pre>np.random.seed(0)\nn_nodes = 5\n\ngraph = nx.gnp_random_graph(n_nodes, .25, seed=42)\nnx.draw(graph, with_labels=True)\n</pre> np.random.seed(0) n_nodes = 5  graph = nx.gnp_random_graph(n_nodes, .25, seed=42) nx.draw(graph, with_labels=True) In\u00a0[32]: Copied! <pre>from pyqtorch.matrices import generate_ising_from_graph, sum_N\nising_matrix = generate_ising_from_graph(graph, type_ising='N')\nising_cost = 1.2*ising_matrix - sum_N(n_nodes)\n\nising_matrix = ising_matrix.reshape([2] * n_nodes + [1])\nising_cost = ising_cost.reshape([2] * n_nodes + [1])\n\n\nclass MIS(QuantumCircuit):\n    def __init__(self, n_qubits, n_layers):\n        super().__init__(n_qubits)\n        self.beta = nn.Parameter(torch.empty(n_layers,))\n        self.gamma = nn.Parameter(torch.empty(n_layers,))\n        self.reset_parameters()\n        \n    def reset_parameters(self):\n        init.uniform_(self.beta, -2 * np.pi, 2 * np.pi)\n        init.uniform_(self.gamma, -2 * np.pi, 2 * np.pi)\n        \n    def forward(self, return_cost=False):\n        state = self.uniform_state()\n        for b, g in zip(self.beta, self.gamma):\n            state = state * torch.exp(-1j * g * ising_matrix)\n            for i in range(self.n_qubits):\n                state = RX(b, state, [i], self.n_qubits)\n        if return_cost:\n            return torch.real(torch.sum(torch.abs(state)**2 * ising_cost))\n        else:\n            state = state.reshape((2**self.n_qubits,))\n            return torch.abs(state)**2\n</pre> from pyqtorch.matrices import generate_ising_from_graph, sum_N ising_matrix = generate_ising_from_graph(graph, type_ising='N') ising_cost = 1.2*ising_matrix - sum_N(n_nodes)  ising_matrix = ising_matrix.reshape([2] * n_nodes + [1]) ising_cost = ising_cost.reshape([2] * n_nodes + [1])   class MIS(QuantumCircuit):     def __init__(self, n_qubits, n_layers):         super().__init__(n_qubits)         self.beta = nn.Parameter(torch.empty(n_layers,))         self.gamma = nn.Parameter(torch.empty(n_layers,))         self.reset_parameters()              def reset_parameters(self):         init.uniform_(self.beta, -2 * np.pi, 2 * np.pi)         init.uniform_(self.gamma, -2 * np.pi, 2 * np.pi)              def forward(self, return_cost=False):         state = self.uniform_state()         for b, g in zip(self.beta, self.gamma):             state = state * torch.exp(-1j * g * ising_matrix)             for i in range(self.n_qubits):                 state = RX(b, state, [i], self.n_qubits)         if return_cost:             return torch.real(torch.sum(torch.abs(state)**2 * ising_cost))         else:             state = state.reshape((2**self.n_qubits,))             return torch.abs(state)**2 In\u00a0[33]: Copied! <pre>model = MIS(n_nodes, 20)\n\noptimizer = torch.optim.Adam(model.parameters(), lr=.02)\nepochs = 100\n\n\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    loss = model(True)\n    loss.backward()\n    optimizer.step()\n    if epoch%50 == 0:\n        print(f\"Epoch {epoch} | Loss {loss}\")\n</pre> model = MIS(n_nodes, 20)  optimizer = torch.optim.Adam(model.parameters(), lr=.02) epochs = 100   for epoch in range(epochs):     optimizer.zero_grad()     loss = model(True)     loss.backward()     optimizer.step()     if epoch%50 == 0:         print(f\"Epoch {epoch} | Loss {loss}\") <pre>Epoch 0 | Loss -0.5000000000000002\nEpoch 50 | Loss -0.5000000000000002\n</pre> In\u00a0[27]: Copied! <pre>prob = model()\nmis = torch.argmax(prob)\nformat(mis, '010b')\n</pre> prob = model() mis = torch.argmax(prob) format(mis, '010b') Out[27]: <pre>'0011111001'</pre> In\u00a0[28]: Copied! <pre>mis\n</pre> mis Out[28]: <pre>tensor(249)</pre> In\u00a0[29]: Copied! <pre>\"{0:b}\".format(1)\n</pre> \"{0:b}\".format(1) Out[29]: <pre>'1'</pre> In\u00a0[30]: Copied! <pre>sum_N(n_nodes)[mis]\n</pre> sum_N(n_nodes)[mis] Out[30]: <pre>tensor(6.+0.j, dtype=torch.complex128)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"deprecated/QAOA/#solve-mis-for-qaoa","title":"Solve MIS for QAOA\u00b6","text":""},{"location":"deprecated/bench/","title":"Bench","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\n</pre> from __future__ import annotations In\u00a0[\u00a0]: Copied! <pre>import time\n</pre> import time In\u00a0[\u00a0]: Copied! <pre>import torch\n</pre> import torch In\u00a0[\u00a0]: Copied! <pre>from pyqtorch.core.batched_operation import batchedRX\nfrom pyqtorch.modules import RX, QuantumCircuit, zero_state\nfrom pyqtorch.modules.parametric import RotationGate\nfrom pyqtorch.modules.primitive import ControlledOperationGate\n</pre> from pyqtorch.core.batched_operation import batchedRX from pyqtorch.modules import RX, QuantumCircuit, zero_state from pyqtorch.modules.parametric import RotationGate from pyqtorch.modules.primitive import ControlledOperationGate In\u00a0[\u00a0]: Copied! <pre>def timeit(f, *args, niters=100):\n    t = 0\n    for _ in range(niters):\n        t0 = time.time()\n        out = f(*args)\n        t1 = time.time()\n        t += t1 - t0\n    return t / niters, out\n</pre> def timeit(f, *args, niters=100):     t = 0     for _ in range(niters):         t0 = time.time()         out = f(*args)         t1 = time.time()         t += t1 - t0     return t / niters, out In\u00a0[\u00a0]: Copied! <pre>dtype = torch.cdouble\ndevice = \"cuda\"\nbatch_size = 1000\nqubits = [0]\nn_qubits = 10\n</pre> dtype = torch.cdouble device = \"cuda\" batch_size = 1000 qubits = [0] n_qubits = 10 In\u00a0[\u00a0]: Copied! <pre>state = zero_state(n_qubits, batch_size=batch_size, device=device, dtype=dtype)\nphi = torch.rand(batch_size, device=device, dtype=dtype)\nthetas = {\"phi\": phi}\n</pre> state = zero_state(n_qubits, batch_size=batch_size, device=device, dtype=dtype) phi = torch.rand(batch_size, device=device, dtype=dtype) thetas = {\"phi\": phi} In\u00a0[\u00a0]: Copied! <pre>func_time, func_out = timeit(batchedRX, phi, state, qubits, n_qubits)\n</pre> func_time, func_out = timeit(batchedRX, phi, state, qubits, n_qubits) In\u00a0[\u00a0]: Copied! <pre>gate = RX(qubits, n_qubits, \"phi\").to(device=device, dtype=dtype)\nmod_time, mod_out = timeit(gate, thetas, state)\n</pre> gate = RX(qubits, n_qubits, \"phi\").to(device=device, dtype=dtype) mod_time, mod_out = timeit(gate, thetas, state) In\u00a0[\u00a0]: Copied! <pre>print(f\"Functional pyq: {func_time}\")\nprint(f\"Module pyq:     {mod_time}\")\nprint(f\"Same results:   {torch.allclose(func_out, mod_out)}\")\n</pre> print(f\"Functional pyq: {func_time}\") print(f\"Module pyq:     {mod_time}\") print(f\"Same results:   {torch.allclose(func_out, mod_out)}\") In\u00a0[\u00a0]: Copied! <pre>circ = QuantumCircuit(\n    n_qubits,\n    [\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        RotationGate(\"Y\", (0,), 10, \"phi\"),\n        RotationGate(\"Y\", (1,), 10, \"phi\"),\n        RotationGate(\"Y\", (2,), 10, \"phi\"),\n        RotationGate(\"Y\", (3,), 10, \"phi\"),\n        RotationGate(\"Y\", (4,), 10, \"phi\"),\n        RotationGate(\"Y\", (5,), 10, \"phi\"),\n        RotationGate(\"Y\", (6,), 10, \"phi\"),\n        RotationGate(\"Y\", (7,), 10, \"phi\"),\n        RotationGate(\"Y\", (8,), 10, \"phi\"),\n        RotationGate(\"Y\", (9,), 10, \"phi\"),\n        RotationGate(\"X\", (0,), 10, \"phi\"),\n        RotationGate(\"X\", (1,), 10, \"phi\"),\n        RotationGate(\"X\", (2,), 10, \"phi\"),\n        RotationGate(\"X\", (3,), 10, \"phi\"),\n        RotationGate(\"X\", (4,), 10, \"phi\"),\n        RotationGate(\"X\", (5,), 10, \"phi\"),\n        RotationGate(\"X\", (6,), 10, \"phi\"),\n        RotationGate(\"X\", (7,), 10, \"phi\"),\n        RotationGate(\"X\", (8,), 10, \"phi\"),\n        RotationGate(\"X\", (9,), 10, \"phi\"),\n        ControlledOperationGate(\"X\", (0, 1), 10),\n        ControlledOperationGate(\"X\", (2, 3), 10),\n        ControlledOperationGate(\"X\", (4, 5), 10),\n        ControlledOperationGate(\"X\", (6, 7), 10),\n        ControlledOperationGate(\"X\", (8, 9), 10),\n        ControlledOperationGate(\"X\", (1, 2), 10),\n        ControlledOperationGate(\"X\", (3, 4), 10),\n        ControlledOperationGate(\"X\", (5, 6), 10),\n        ControlledOperationGate(\"X\", (7, 8), 10),\n    ],\n).to(device=device, dtype=dtype)\n</pre> circ = QuantumCircuit(     n_qubits,     [         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         RotationGate(\"Y\", (0,), 10, \"phi\"),         RotationGate(\"Y\", (1,), 10, \"phi\"),         RotationGate(\"Y\", (2,), 10, \"phi\"),         RotationGate(\"Y\", (3,), 10, \"phi\"),         RotationGate(\"Y\", (4,), 10, \"phi\"),         RotationGate(\"Y\", (5,), 10, \"phi\"),         RotationGate(\"Y\", (6,), 10, \"phi\"),         RotationGate(\"Y\", (7,), 10, \"phi\"),         RotationGate(\"Y\", (8,), 10, \"phi\"),         RotationGate(\"Y\", (9,), 10, \"phi\"),         RotationGate(\"X\", (0,), 10, \"phi\"),         RotationGate(\"X\", (1,), 10, \"phi\"),         RotationGate(\"X\", (2,), 10, \"phi\"),         RotationGate(\"X\", (3,), 10, \"phi\"),         RotationGate(\"X\", (4,), 10, \"phi\"),         RotationGate(\"X\", (5,), 10, \"phi\"),         RotationGate(\"X\", (6,), 10, \"phi\"),         RotationGate(\"X\", (7,), 10, \"phi\"),         RotationGate(\"X\", (8,), 10, \"phi\"),         RotationGate(\"X\", (9,), 10, \"phi\"),         ControlledOperationGate(\"X\", (0, 1), 10),         ControlledOperationGate(\"X\", (2, 3), 10),         ControlledOperationGate(\"X\", (4, 5), 10),         ControlledOperationGate(\"X\", (6, 7), 10),         ControlledOperationGate(\"X\", (8, 9), 10),         ControlledOperationGate(\"X\", (1, 2), 10),         ControlledOperationGate(\"X\", (3, 4), 10),         ControlledOperationGate(\"X\", (5, 6), 10),         ControlledOperationGate(\"X\", (7, 8), 10),     ], ).to(device=device, dtype=dtype) In\u00a0[\u00a0]: Copied! <pre>circ(thetas, state)\n</pre> circ(thetas, state) In\u00a0[\u00a0]: Copied! <pre>print(timeit(circ, thetas, state))\n</pre> print(timeit(circ, thetas, state))"},{"location":"deprecated/fit_function/","title":"Fit function","text":"In\u00a0[12]: Copied! <pre>import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.nn.init as init\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nfrom pyqtorch.core.circuit import QuantumCircuit\nfrom pyqtorch.ansatz import AlternateLayerAnsatz\nfrom pyqtorch.embedding import SingleLayerEncoding\nfrom pyqtorch.core.operation import Z, RX\n</pre> import torch import torch.nn as nn import torch.nn.functional as F import torch.nn.init as init  import numpy as np import matplotlib.pyplot as plt import networkx as nx  from pyqtorch.core.circuit import QuantumCircuit from pyqtorch.ansatz import AlternateLayerAnsatz from pyqtorch.embedding import SingleLayerEncoding from pyqtorch.core.operation import Z, RX In\u00a0[2]: Copied! <pre>def target_function(x, degree=3):\n    result = 0\n    for i in range(degree):\n        result += torch.cos(i*x) + torch.sin(i*x)\n    return .05 * result\n</pre> def target_function(x, degree=3):     result = 0     for i in range(degree):         result += torch.cos(i*x) + torch.sin(i*x)     return .05 * result In\u00a0[3]: Copied! <pre>x = torch.tensor(np.linspace(0, 10, 100))\ntarget_y = target_function(x, 5)\nplt.plot(x.numpy(), target_y.numpy())\n</pre> x = torch.tensor(np.linspace(0, 10, 100)) target_y = target_function(x, 5) plt.plot(x.numpy(), target_y.numpy()) Out[3]: <pre>[&lt;matplotlib.lines.Line2D at 0x1353b3850&gt;]</pre> In\u00a0[4]: Copied! <pre>class Model(QuantumCircuit):\n    def __init__(self, n_qubits, n_layers):\n        super().__init__(n_qubits)\n        self.ansatz1 = AlternateLayerAnsatz(n_qubits, n_layers)\n        self.embedding = SingleLayerEncoding(n_qubits)\n        self.ansatz2 = AlternateLayerAnsatz(n_qubits, n_layers)\n        \n        \n    def forward(self, x):\n        batch_size = len(x)\n        state = self.init_state(batch_size)\n        \n        state = self.ansatz1(state)\n        state = self.embedding(state, x)\n        state = self.ansatz2(state)\n        \n        new_state = Z(state, [0], self.n_qubits)\n        \n        state = state.reshape((2**self.n_qubits, batch_size))\n        new_state = new_state.reshape((2**self.n_qubits, batch_size))\n        \n        return torch.real(torch.sum(torch.conj(state) * new_state, axis=0))\n</pre> class Model(QuantumCircuit):     def __init__(self, n_qubits, n_layers):         super().__init__(n_qubits)         self.ansatz1 = AlternateLayerAnsatz(n_qubits, n_layers)         self.embedding = SingleLayerEncoding(n_qubits)         self.ansatz2 = AlternateLayerAnsatz(n_qubits, n_layers)                       def forward(self, x):         batch_size = len(x)         state = self.init_state(batch_size)                  state = self.ansatz1(state)         state = self.embedding(state, x)         state = self.ansatz2(state)                  new_state = Z(state, [0], self.n_qubits)                  state = state.reshape((2**self.n_qubits, batch_size))         new_state = new_state.reshape((2**self.n_qubits, batch_size))                  return torch.real(torch.sum(torch.conj(state) * new_state, axis=0)) In\u00a0[5]: Copied! <pre>n_qubits = 5\nn_layers = 3\n\nmodel = Model(n_qubits, n_layers)\n</pre> n_qubits = 5 n_layers = 3  model = Model(n_qubits, n_layers) In\u00a0[6]: Copied! <pre>with torch.no_grad():\n    y = model(x)\n</pre> with torch.no_grad():     y = model(x) In\u00a0[7]: Copied! <pre>model(x[0:10]).shape\n</pre> model(x[0:10]).shape Out[7]: <pre>torch.Size([10])</pre> In\u00a0[8]: Copied! <pre>plt.plot(x.numpy(), y.numpy())\n</pre> plt.plot(x.numpy(), y.numpy()) Out[8]: <pre>[&lt;matplotlib.lines.Line2D at 0x135522550&gt;]</pre> In\u00a0[12]: Copied! <pre>optimizer = torch.optim.Adam(model.parameters(), lr=.01)\nepochs = 200\n\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    y_pred = model(x)\n    loss = F.mse_loss(target_y, y_pred)\n    loss.backward()\n    optimizer.step()\n    print(f\"Epoch {epoch+1} | Loss {loss}\")\n</pre> optimizer = torch.optim.Adam(model.parameters(), lr=.01) epochs = 200  for epoch in range(epochs):     optimizer.zero_grad()     y_pred = model(x)     loss = F.mse_loss(target_y, y_pred)     loss.backward()     optimizer.step()     print(f\"Epoch {epoch+1} | Loss {loss}\") <pre>Epoch 1 | Loss 7.976638980490219e-05\nEpoch 2 | Loss 0.00018516320389538174\nEpoch 3 | Loss 0.00015250069418123508\nEpoch 4 | Loss 0.0002954347442288451\nEpoch 5 | Loss 9.96617571595185e-05\nEpoch 6 | Loss 0.00015587379722353136\nEpoch 7 | Loss 0.00014239923158366834\nEpoch 8 | Loss 0.0001117781615256353\nEpoch 9 | Loss 0.00011458096332979135\nEpoch 10 | Loss 8.521301757740507e-05\nEpoch 11 | Loss 9.186455606689106e-05\nEpoch 12 | Loss 0.00011302529934456084\nEpoch 13 | Loss 7.959300999009852e-05\nEpoch 14 | Loss 5.2588442274184146e-05\nEpoch 15 | Loss 6.899284437318874e-05\nEpoch 16 | Loss 7.712150554875724e-05\nEpoch 17 | Loss 6.734313331522322e-05\nEpoch 18 | Loss 6.244483340190226e-05\nEpoch 19 | Loss 5.285628239744807e-05\nEpoch 20 | Loss 4.327889542059836e-05\nEpoch 21 | Loss 5.068718981105365e-05\nEpoch 22 | Loss 5.669043898201916e-05\nEpoch 23 | Loss 4.6521824954857976e-05\nEpoch 24 | Loss 3.854451028245699e-05\nEpoch 25 | Loss 3.95755427944772e-05\nEpoch 26 | Loss 3.800998614927786e-05\nEpoch 27 | Loss 3.6745510730459526e-05\nEpoch 28 | Loss 3.8465455192760104e-05\nEpoch 29 | Loss 3.437600066547346e-05\nEpoch 30 | Loss 2.8812066489541125e-05\nEpoch 31 | Loss 2.9533549586861484e-05\nEpoch 32 | Loss 2.957608565436818e-05\nEpoch 33 | Loss 2.7057626252388196e-05\nEpoch 34 | Loss 2.70324853383119e-05\nEpoch 35 | Loss 2.5590466241145823e-05\nEpoch 36 | Loss 2.2220650462571644e-05\nEpoch 37 | Loss 2.220132989663142e-05\nEpoch 38 | Loss 2.2136436191051248e-05\nEpoch 39 | Loss 2.0002222695958007e-05\nEpoch 40 | Loss 1.9640672124990093e-05\nEpoch 41 | Loss 1.895554494504721e-05\nEpoch 42 | Loss 1.7144345792850507e-05\nEpoch 43 | Loss 1.6844903715821374e-05\nEpoch 44 | Loss 1.5908082788713718e-05\nEpoch 45 | Loss 1.447484953566956e-05\nEpoch 46 | Loss 1.4662099736617871e-05\nEpoch 47 | Loss 1.4145107022944017e-05\nEpoch 48 | Loss 1.2795466674104107e-05\nEpoch 49 | Loss 1.211236915921406e-05\nEpoch 50 | Loss 1.1353350391973016e-05\nEpoch 51 | Loss 1.1081852013021272e-05\nEpoch 52 | Loss 1.100209740501172e-05\nEpoch 53 | Loss 9.869642995512337e-06\nEpoch 54 | Loss 9.007742551158593e-06\nEpoch 55 | Loss 8.874283108322652e-06\nEpoch 56 | Loss 8.52651521296105e-06\nEpoch 57 | Loss 8.12172730360669e-06\nEpoch 58 | Loss 7.459735999860909e-06\nEpoch 59 | Loss 6.827688820842336e-06\nEpoch 60 | Loss 6.785692585776636e-06\nEpoch 61 | Loss 6.45539706286123e-06\nEpoch 62 | Loss 5.894215803868307e-06\nEpoch 63 | Loss 5.56098994120402e-06\nEpoch 64 | Loss 5.209685349211364e-06\nEpoch 65 | Loss 5.027929888167854e-06\nEpoch 66 | Loss 4.704096830116435e-06\nEpoch 67 | Loss 4.300515534936481e-06\nEpoch 68 | Loss 4.150485565538104e-06\nEpoch 69 | Loss 3.877569473355058e-06\nEpoch 70 | Loss 3.6016460974809315e-06\nEpoch 71 | Loss 3.3824982572675673e-06\nEpoch 72 | Loss 3.16966959953517e-06\nEpoch 73 | Loss 3.030399304437687e-06\nEpoch 74 | Loss 2.76945424485514e-06\nEpoch 75 | Loss 2.553054371774435e-06\nEpoch 76 | Loss 2.4448968670808195e-06\nEpoch 77 | Loss 2.2889466512651473e-06\nEpoch 78 | Loss 2.131864339904989e-06\nEpoch 79 | Loss 1.946444993085096e-06\nEpoch 80 | Loss 1.8250938955374872e-06\nEpoch 81 | Loss 1.737781328244668e-06\nEpoch 82 | Loss 1.5917553754898976e-06\nEpoch 83 | Loss 1.4797073287116884e-06\nEpoch 84 | Loss 1.3673760112968568e-06\nEpoch 85 | Loss 1.2841187042706526e-06\nEpoch 86 | Loss 1.1946987781088069e-06\nEpoch 87 | Loss 1.0950192864944728e-06\nEpoch 88 | Loss 1.0252991498133102e-06\nEpoch 89 | Loss 9.441709891350378e-07\nEpoch 90 | Loss 8.802933932194375e-07\nEpoch 91 | Loss 8.132572461557469e-07\nEpoch 92 | Loss 7.505187111568322e-07\nEpoch 93 | Loss 6.966418777239547e-07\nEpoch 94 | Loss 6.404785773511559e-07\nEpoch 95 | Loss 5.988044546804841e-07\nEpoch 96 | Loss 5.489020536184141e-07\nEpoch 97 | Loss 5.069285331770859e-07\nEpoch 98 | Loss 4.6839833041967234e-07\nEpoch 99 | Loss 4.330229784719919e-07\nEpoch 100 | Loss 4.01301779468656e-07\nEpoch 101 | Loss 3.6702312795055337e-07\nEpoch 102 | Loss 3.412788199584224e-07\nEpoch 103 | Loss 3.126745305312052e-07\nEpoch 104 | Loss 2.900542128553373e-07\nEpoch 105 | Loss 2.673624858901556e-07\nEpoch 106 | Loss 2.467128937298071e-07\nEpoch 107 | Loss 2.2656895489334856e-07\nEpoch 108 | Loss 2.085350333653908e-07\nEpoch 109 | Loss 1.9469188536848812e-07\nEpoch 110 | Loss 1.7820164935276283e-07\nEpoch 111 | Loss 1.640496481019208e-07\nEpoch 112 | Loss 1.5106211262608455e-07\nEpoch 113 | Loss 1.4119848223789955e-07\nEpoch 114 | Loss 1.292007696718066e-07\nEpoch 115 | Loss 1.1874412702599467e-07\nEpoch 116 | Loss 1.1027902270851239e-07\nEpoch 117 | Loss 1.0224775106258967e-07\nEpoch 118 | Loss 9.397244913387625e-08\nEpoch 119 | Loss 8.638233314437162e-08\nEpoch 120 | Loss 8.06963340770389e-08\nEpoch 121 | Loss 7.429052919349288e-08\nEpoch 122 | Loss 6.864083280756386e-08\nEpoch 123 | Loss 6.33055696357184e-08\nEpoch 124 | Loss 5.899834870509737e-08\nEpoch 125 | Loss 5.4242624712314306e-08\nEpoch 126 | Loss 5.034641898340614e-08\nEpoch 127 | Loss 4.660330291945879e-08\nEpoch 128 | Loss 4.314035280090745e-08\nEpoch 129 | Loss 3.981389918540132e-08\nEpoch 130 | Loss 3.704318295355837e-08\nEpoch 131 | Loss 3.4305289858396905e-08\nEpoch 132 | Loss 3.1603543001644865e-08\nEpoch 133 | Loss 2.932675616681832e-08\nEpoch 134 | Loss 2.7229185806650127e-08\nEpoch 135 | Loss 2.520537197082856e-08\nEpoch 136 | Loss 2.3212538811910533e-08\nEpoch 137 | Loss 2.1593655612378752e-08\nEpoch 138 | Loss 1.9959724261288564e-08\nEpoch 139 | Loss 1.848102724875526e-08\nEpoch 140 | Loss 1.7027341753179298e-08\nEpoch 141 | Loss 1.5813454030146326e-08\nEpoch 142 | Loss 1.4578917522711054e-08\nEpoch 143 | Loss 1.3489509966222379e-08\nEpoch 144 | Loss 1.2418868714184316e-08\nEpoch 145 | Loss 1.1502672471082855e-08\nEpoch 146 | Loss 1.059197351504494e-08\nEpoch 147 | Loss 9.77656057985274e-09\nEpoch 148 | Loss 8.973389180762976e-09\nEpoch 149 | Loss 8.29561541610071e-09\nEpoch 150 | Loss 7.622592994314037e-09\nEpoch 151 | Loss 7.009538649847957e-09\nEpoch 152 | Loss 6.42317602452753e-09\nEpoch 153 | Loss 5.922748802421972e-09\nEpoch 154 | Loss 5.416817199714565e-09\nEpoch 155 | Loss 4.97056685968615e-09\nEpoch 156 | Loss 4.548607161353243e-09\nEpoch 157 | Loss 4.166262719362401e-09\nEpoch 158 | Loss 3.801337132542815e-09\nEpoch 159 | Loss 3.4831560781203587e-09\nEpoch 160 | Loss 3.169006122372877e-09\nEpoch 161 | Loss 2.890839248064704e-09\nEpoch 162 | Loss 2.631715595460305e-09\nEpoch 163 | Loss 2.40175223653661e-09\nEpoch 164 | Loss 2.1709880287419868e-09\nEpoch 165 | Loss 1.9793050924534993e-09\nEpoch 166 | Loss 1.7947676471210319e-09\nEpoch 167 | Loss 1.6246952978985594e-09\nEpoch 168 | Loss 1.4662527536720128e-09\nEpoch 169 | Loss 1.3339776518865908e-09\nEpoch 170 | Loss 1.198592456232976e-09\nEpoch 171 | Loss 1.0805168769488162e-09\nEpoch 172 | Loss 9.745193630127017e-10\nEpoch 173 | Loss 8.790876549097978e-10\nEpoch 174 | Loss 7.861964944597971e-10\nEpoch 175 | Loss 7.081532756848237e-10\nEpoch 176 | Loss 6.343271518451939e-10\nEpoch 177 | Loss 5.686702897385907e-10\nEpoch 178 | Loss 5.081131012009327e-10\nEpoch 179 | Loss 4.540037138717548e-10\nEpoch 180 | Loss 4.045487719974579e-10\nEpoch 181 | Loss 3.613877312708314e-10\nEpoch 182 | Loss 3.21198860300143e-10\nEpoch 183 | Loss 2.854309803476494e-10\nEpoch 184 | Loss 2.537583324023182e-10\nEpoch 185 | Loss 2.244044223897077e-10\nEpoch 186 | Loss 1.99460459616564e-10\nEpoch 187 | Loss 1.7593777950857055e-10\nEpoch 188 | Loss 1.5583428623061128e-10\nEpoch 189 | Loss 1.3767095584122574e-10\nEpoch 190 | Loss 1.2213353501262156e-10\nEpoch 191 | Loss 1.0617428195852059e-10\nEpoch 192 | Loss 9.563760842007555e-11\nEpoch 193 | Loss 8.258923837690156e-11\nEpoch 194 | Loss 7.227734310396987e-11\nEpoch 195 | Loss 6.424510857200186e-11\nEpoch 196 | Loss 5.537511064809611e-11\nEpoch 197 | Loss 4.8596399538342986e-11\nEpoch 198 | Loss 4.2393518257747763e-11\nEpoch 199 | Loss 3.7616087065908444e-11\nEpoch 200 | Loss 3.165019865970098e-11\n</pre> In\u00a0[13]: Copied! <pre>with torch.no_grad():\n    y = model(x)\n\nplt.plot(x.numpy(), target_y.numpy())    \nplt.plot(x.numpy(), y.numpy())\n</pre> with torch.no_grad():     y = model(x)  plt.plot(x.numpy(), target_y.numpy())     plt.plot(x.numpy(), y.numpy()) Out[13]: <pre>[&lt;matplotlib.lines.Line2D at 0x13584d760&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"deprecated/fit_function/#fit-a-target-function","title":"Fit a target function\u00b6","text":""},{"location":"deprecated/getting_started/","title":"Getting started","text":"In\u00a0[12]: Copied! <pre>import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.nn.init as init\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nfrom pyqtorch.core.circuit import QuantumCircuit\nfrom pyqtorch.ansatz import AlternateLayerAnsatz\nfrom pyqtorch.embedding import SingleLayerEncoding\nfrom pyqtorch.core.operation import Z, RX\n</pre> import torch import torch.nn as nn import torch.nn.functional as F import torch.nn.init as init  import numpy as np import matplotlib.pyplot as plt import networkx as nx  from pyqtorch.core.circuit import QuantumCircuit from pyqtorch.ansatz import AlternateLayerAnsatz from pyqtorch.embedding import SingleLayerEncoding from pyqtorch.core.operation import Z, RX In\u00a0[2]: Copied! <pre>def target_function(x, degree=3):\n    result = 0\n    for i in range(degree):\n        result += torch.cos(i*x) + torch.sin(i*x)\n    return .05 * result\n</pre> def target_function(x, degree=3):     result = 0     for i in range(degree):         result += torch.cos(i*x) + torch.sin(i*x)     return .05 * result In\u00a0[3]: Copied! <pre>x = torch.tensor(np.linspace(0, 10, 100))\ntarget_y = target_function(x, 5)\nplt.plot(x.numpy(), target_y.numpy())\n</pre> x = torch.tensor(np.linspace(0, 10, 100)) target_y = target_function(x, 5) plt.plot(x.numpy(), target_y.numpy()) Out[3]: <pre>[&lt;matplotlib.lines.Line2D at 0x1353b3850&gt;]</pre> In\u00a0[4]: Copied! <pre>class Model(QuantumCircuit):\n    def __init__(self, n_qubits, n_layers):\n        super().__init__(n_qubits)\n        self.ansatz1 = AlternateLayerAnsatz(n_qubits, n_layers)\n        self.embedding = SingleLayerEncoding(n_qubits)\n        self.ansatz2 = AlternateLayerAnsatz(n_qubits, n_layers)\n        \n        \n    def forward(self, x):\n        batch_size = len(x)\n        state = self.init_state(batch_size)\n        \n        state = self.ansatz1(state)\n        state = self.embedding(state, x)\n        state = self.ansatz2(state)\n        \n        new_state = Z(state, [0], self.n_qubits)\n        \n        state = state.reshape((2**self.n_qubits, batch_size))\n        new_state = new_state.reshape((2**self.n_qubits, batch_size))\n        \n        return torch.real(torch.sum(torch.conj(state) * new_state, axis=0))\n</pre> class Model(QuantumCircuit):     def __init__(self, n_qubits, n_layers):         super().__init__(n_qubits)         self.ansatz1 = AlternateLayerAnsatz(n_qubits, n_layers)         self.embedding = SingleLayerEncoding(n_qubits)         self.ansatz2 = AlternateLayerAnsatz(n_qubits, n_layers)                       def forward(self, x):         batch_size = len(x)         state = self.init_state(batch_size)                  state = self.ansatz1(state)         state = self.embedding(state, x)         state = self.ansatz2(state)                  new_state = Z(state, [0], self.n_qubits)                  state = state.reshape((2**self.n_qubits, batch_size))         new_state = new_state.reshape((2**self.n_qubits, batch_size))                  return torch.real(torch.sum(torch.conj(state) * new_state, axis=0)) In\u00a0[5]: Copied! <pre>n_qubits = 5\nn_layers = 3\n\nmodel = Model(n_qubits, n_layers)\n</pre> n_qubits = 5 n_layers = 3  model = Model(n_qubits, n_layers) In\u00a0[6]: Copied! <pre>with torch.no_grad():\n    y = model(x)\n</pre> with torch.no_grad():     y = model(x) In\u00a0[7]: Copied! <pre>model(x[0:10]).shape\n</pre> model(x[0:10]).shape Out[7]: <pre>torch.Size([10])</pre> In\u00a0[8]: Copied! <pre>plt.plot(x.numpy(), y.numpy())\n</pre> plt.plot(x.numpy(), y.numpy()) Out[8]: <pre>[&lt;matplotlib.lines.Line2D at 0x135522550&gt;]</pre> In\u00a0[12]: Copied! <pre>optimizer = torch.optim.Adam(model.parameters(), lr=.01)\nepochs = 200\n\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    y_pred = model(x)\n    loss = F.mse_loss(target_y, y_pred)\n    loss.backward()\n    optimizer.step()\n    print(f\"Epoch {epoch+1} | Loss {loss}\")\n</pre> optimizer = torch.optim.Adam(model.parameters(), lr=.01) epochs = 200  for epoch in range(epochs):     optimizer.zero_grad()     y_pred = model(x)     loss = F.mse_loss(target_y, y_pred)     loss.backward()     optimizer.step()     print(f\"Epoch {epoch+1} | Loss {loss}\") <pre>Epoch 1 | Loss 7.976638980490219e-05\nEpoch 2 | Loss 0.00018516320389538174\nEpoch 3 | Loss 0.00015250069418123508\nEpoch 4 | Loss 0.0002954347442288451\nEpoch 5 | Loss 9.96617571595185e-05\nEpoch 6 | Loss 0.00015587379722353136\nEpoch 7 | Loss 0.00014239923158366834\nEpoch 8 | Loss 0.0001117781615256353\nEpoch 9 | Loss 0.00011458096332979135\nEpoch 10 | Loss 8.521301757740507e-05\nEpoch 11 | Loss 9.186455606689106e-05\nEpoch 12 | Loss 0.00011302529934456084\nEpoch 13 | Loss 7.959300999009852e-05\nEpoch 14 | Loss 5.2588442274184146e-05\nEpoch 15 | Loss 6.899284437318874e-05\nEpoch 16 | Loss 7.712150554875724e-05\nEpoch 17 | Loss 6.734313331522322e-05\nEpoch 18 | Loss 6.244483340190226e-05\nEpoch 19 | Loss 5.285628239744807e-05\nEpoch 20 | Loss 4.327889542059836e-05\nEpoch 21 | Loss 5.068718981105365e-05\nEpoch 22 | Loss 5.669043898201916e-05\nEpoch 23 | Loss 4.6521824954857976e-05\nEpoch 24 | Loss 3.854451028245699e-05\nEpoch 25 | Loss 3.95755427944772e-05\nEpoch 26 | Loss 3.800998614927786e-05\nEpoch 27 | Loss 3.6745510730459526e-05\nEpoch 28 | Loss 3.8465455192760104e-05\nEpoch 29 | Loss 3.437600066547346e-05\nEpoch 30 | Loss 2.8812066489541125e-05\nEpoch 31 | Loss 2.9533549586861484e-05\nEpoch 32 | Loss 2.957608565436818e-05\nEpoch 33 | Loss 2.7057626252388196e-05\nEpoch 34 | Loss 2.70324853383119e-05\nEpoch 35 | Loss 2.5590466241145823e-05\nEpoch 36 | Loss 2.2220650462571644e-05\nEpoch 37 | Loss 2.220132989663142e-05\nEpoch 38 | Loss 2.2136436191051248e-05\nEpoch 39 | Loss 2.0002222695958007e-05\nEpoch 40 | Loss 1.9640672124990093e-05\nEpoch 41 | Loss 1.895554494504721e-05\nEpoch 42 | Loss 1.7144345792850507e-05\nEpoch 43 | Loss 1.6844903715821374e-05\nEpoch 44 | Loss 1.5908082788713718e-05\nEpoch 45 | Loss 1.447484953566956e-05\nEpoch 46 | Loss 1.4662099736617871e-05\nEpoch 47 | Loss 1.4145107022944017e-05\nEpoch 48 | Loss 1.2795466674104107e-05\nEpoch 49 | Loss 1.211236915921406e-05\nEpoch 50 | Loss 1.1353350391973016e-05\nEpoch 51 | Loss 1.1081852013021272e-05\nEpoch 52 | Loss 1.100209740501172e-05\nEpoch 53 | Loss 9.869642995512337e-06\nEpoch 54 | Loss 9.007742551158593e-06\nEpoch 55 | Loss 8.874283108322652e-06\nEpoch 56 | Loss 8.52651521296105e-06\nEpoch 57 | Loss 8.12172730360669e-06\nEpoch 58 | Loss 7.459735999860909e-06\nEpoch 59 | Loss 6.827688820842336e-06\nEpoch 60 | Loss 6.785692585776636e-06\nEpoch 61 | Loss 6.45539706286123e-06\nEpoch 62 | Loss 5.894215803868307e-06\nEpoch 63 | Loss 5.56098994120402e-06\nEpoch 64 | Loss 5.209685349211364e-06\nEpoch 65 | Loss 5.027929888167854e-06\nEpoch 66 | Loss 4.704096830116435e-06\nEpoch 67 | Loss 4.300515534936481e-06\nEpoch 68 | Loss 4.150485565538104e-06\nEpoch 69 | Loss 3.877569473355058e-06\nEpoch 70 | Loss 3.6016460974809315e-06\nEpoch 71 | Loss 3.3824982572675673e-06\nEpoch 72 | Loss 3.16966959953517e-06\nEpoch 73 | Loss 3.030399304437687e-06\nEpoch 74 | Loss 2.76945424485514e-06\nEpoch 75 | Loss 2.553054371774435e-06\nEpoch 76 | Loss 2.4448968670808195e-06\nEpoch 77 | Loss 2.2889466512651473e-06\nEpoch 78 | Loss 2.131864339904989e-06\nEpoch 79 | Loss 1.946444993085096e-06\nEpoch 80 | Loss 1.8250938955374872e-06\nEpoch 81 | Loss 1.737781328244668e-06\nEpoch 82 | Loss 1.5917553754898976e-06\nEpoch 83 | Loss 1.4797073287116884e-06\nEpoch 84 | Loss 1.3673760112968568e-06\nEpoch 85 | Loss 1.2841187042706526e-06\nEpoch 86 | Loss 1.1946987781088069e-06\nEpoch 87 | Loss 1.0950192864944728e-06\nEpoch 88 | Loss 1.0252991498133102e-06\nEpoch 89 | Loss 9.441709891350378e-07\nEpoch 90 | Loss 8.802933932194375e-07\nEpoch 91 | Loss 8.132572461557469e-07\nEpoch 92 | Loss 7.505187111568322e-07\nEpoch 93 | Loss 6.966418777239547e-07\nEpoch 94 | Loss 6.404785773511559e-07\nEpoch 95 | Loss 5.988044546804841e-07\nEpoch 96 | Loss 5.489020536184141e-07\nEpoch 97 | Loss 5.069285331770859e-07\nEpoch 98 | Loss 4.6839833041967234e-07\nEpoch 99 | Loss 4.330229784719919e-07\nEpoch 100 | Loss 4.01301779468656e-07\nEpoch 101 | Loss 3.6702312795055337e-07\nEpoch 102 | Loss 3.412788199584224e-07\nEpoch 103 | Loss 3.126745305312052e-07\nEpoch 104 | Loss 2.900542128553373e-07\nEpoch 105 | Loss 2.673624858901556e-07\nEpoch 106 | Loss 2.467128937298071e-07\nEpoch 107 | Loss 2.2656895489334856e-07\nEpoch 108 | Loss 2.085350333653908e-07\nEpoch 109 | Loss 1.9469188536848812e-07\nEpoch 110 | Loss 1.7820164935276283e-07\nEpoch 111 | Loss 1.640496481019208e-07\nEpoch 112 | Loss 1.5106211262608455e-07\nEpoch 113 | Loss 1.4119848223789955e-07\nEpoch 114 | Loss 1.292007696718066e-07\nEpoch 115 | Loss 1.1874412702599467e-07\nEpoch 116 | Loss 1.1027902270851239e-07\nEpoch 117 | Loss 1.0224775106258967e-07\nEpoch 118 | Loss 9.397244913387625e-08\nEpoch 119 | Loss 8.638233314437162e-08\nEpoch 120 | Loss 8.06963340770389e-08\nEpoch 121 | Loss 7.429052919349288e-08\nEpoch 122 | Loss 6.864083280756386e-08\nEpoch 123 | Loss 6.33055696357184e-08\nEpoch 124 | Loss 5.899834870509737e-08\nEpoch 125 | Loss 5.4242624712314306e-08\nEpoch 126 | Loss 5.034641898340614e-08\nEpoch 127 | Loss 4.660330291945879e-08\nEpoch 128 | Loss 4.314035280090745e-08\nEpoch 129 | Loss 3.981389918540132e-08\nEpoch 130 | Loss 3.704318295355837e-08\nEpoch 131 | Loss 3.4305289858396905e-08\nEpoch 132 | Loss 3.1603543001644865e-08\nEpoch 133 | Loss 2.932675616681832e-08\nEpoch 134 | Loss 2.7229185806650127e-08\nEpoch 135 | Loss 2.520537197082856e-08\nEpoch 136 | Loss 2.3212538811910533e-08\nEpoch 137 | Loss 2.1593655612378752e-08\nEpoch 138 | Loss 1.9959724261288564e-08\nEpoch 139 | Loss 1.848102724875526e-08\nEpoch 140 | Loss 1.7027341753179298e-08\nEpoch 141 | Loss 1.5813454030146326e-08\nEpoch 142 | Loss 1.4578917522711054e-08\nEpoch 143 | Loss 1.3489509966222379e-08\nEpoch 144 | Loss 1.2418868714184316e-08\nEpoch 145 | Loss 1.1502672471082855e-08\nEpoch 146 | Loss 1.059197351504494e-08\nEpoch 147 | Loss 9.77656057985274e-09\nEpoch 148 | Loss 8.973389180762976e-09\nEpoch 149 | Loss 8.29561541610071e-09\nEpoch 150 | Loss 7.622592994314037e-09\nEpoch 151 | Loss 7.009538649847957e-09\nEpoch 152 | Loss 6.42317602452753e-09\nEpoch 153 | Loss 5.922748802421972e-09\nEpoch 154 | Loss 5.416817199714565e-09\nEpoch 155 | Loss 4.97056685968615e-09\nEpoch 156 | Loss 4.548607161353243e-09\nEpoch 157 | Loss 4.166262719362401e-09\nEpoch 158 | Loss 3.801337132542815e-09\nEpoch 159 | Loss 3.4831560781203587e-09\nEpoch 160 | Loss 3.169006122372877e-09\nEpoch 161 | Loss 2.890839248064704e-09\nEpoch 162 | Loss 2.631715595460305e-09\nEpoch 163 | Loss 2.40175223653661e-09\nEpoch 164 | Loss 2.1709880287419868e-09\nEpoch 165 | Loss 1.9793050924534993e-09\nEpoch 166 | Loss 1.7947676471210319e-09\nEpoch 167 | Loss 1.6246952978985594e-09\nEpoch 168 | Loss 1.4662527536720128e-09\nEpoch 169 | Loss 1.3339776518865908e-09\nEpoch 170 | Loss 1.198592456232976e-09\nEpoch 171 | Loss 1.0805168769488162e-09\nEpoch 172 | Loss 9.745193630127017e-10\nEpoch 173 | Loss 8.790876549097978e-10\nEpoch 174 | Loss 7.861964944597971e-10\nEpoch 175 | Loss 7.081532756848237e-10\nEpoch 176 | Loss 6.343271518451939e-10\nEpoch 177 | Loss 5.686702897385907e-10\nEpoch 178 | Loss 5.081131012009327e-10\nEpoch 179 | Loss 4.540037138717548e-10\nEpoch 180 | Loss 4.045487719974579e-10\nEpoch 181 | Loss 3.613877312708314e-10\nEpoch 182 | Loss 3.21198860300143e-10\nEpoch 183 | Loss 2.854309803476494e-10\nEpoch 184 | Loss 2.537583324023182e-10\nEpoch 185 | Loss 2.244044223897077e-10\nEpoch 186 | Loss 1.99460459616564e-10\nEpoch 187 | Loss 1.7593777950857055e-10\nEpoch 188 | Loss 1.5583428623061128e-10\nEpoch 189 | Loss 1.3767095584122574e-10\nEpoch 190 | Loss 1.2213353501262156e-10\nEpoch 191 | Loss 1.0617428195852059e-10\nEpoch 192 | Loss 9.563760842007555e-11\nEpoch 193 | Loss 8.258923837690156e-11\nEpoch 194 | Loss 7.227734310396987e-11\nEpoch 195 | Loss 6.424510857200186e-11\nEpoch 196 | Loss 5.537511064809611e-11\nEpoch 197 | Loss 4.8596399538342986e-11\nEpoch 198 | Loss 4.2393518257747763e-11\nEpoch 199 | Loss 3.7616087065908444e-11\nEpoch 200 | Loss 3.165019865970098e-11\n</pre> In\u00a0[13]: Copied! <pre>with torch.no_grad():\n    y = model(x)\n\nplt.plot(x.numpy(), target_y.numpy())    \nplt.plot(x.numpy(), y.numpy())\n</pre> with torch.no_grad():     y = model(x)  plt.plot(x.numpy(), target_y.numpy())     plt.plot(x.numpy(), y.numpy()) Out[13]: <pre>[&lt;matplotlib.lines.Line2D at 0x13584d760&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"deprecated/getting_started/#fitting-a-function","title":"Fitting a function\u00b6","text":""},{"location":"deprecated/ham_evol_comparison/","title":"Comparing the single hamiltonian evolution","text":"In\u00a0[1]: Copied! <pre>import torch\nimport numpy as np\nimport networkx as nx\n\nfrom pyqtorch.core.circuit import QuantumCircuit\nfrom pyqtorch.core.operation import hamiltonian_evolution, hamiltonian_evolution_eig\nimport copy\n\nfrom pyqtorch.matrices import generate_ising_from_graph\n</pre> import torch import numpy as np import networkx as nx  from pyqtorch.core.circuit import QuantumCircuit from pyqtorch.core.operation import hamiltonian_evolution, hamiltonian_evolution_eig import copy  from pyqtorch.matrices import generate_ising_from_graph <pre>/Users/joaom/mambaforge/envs/qucint/lib/python3.9/site-packages/tqdm/auto.py:22: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>N = 8\np = 0.5\n\ngraph = nx.fast_gnp_random_graph(N, p)\n\nbatch_size = 1\nqc = QuantumCircuit(N)\npsi = qc.uniform_state(batch_size)\npsi_ini = copy.deepcopy(psi)\n\nH_diag = generate_ising_from_graph(graph)\n\nH = torch.diag(H_diag)\n\nqc = QuantumCircuit(N)\npsi = qc.uniform_state(batch_size)\npsi_ini = copy.deepcopy(psi)\n</pre> N = 8 p = 0.5  graph = nx.fast_gnp_random_graph(N, p)  batch_size = 1 qc = QuantumCircuit(N) psi = qc.uniform_state(batch_size) psi_ini = copy.deepcopy(psi)  H_diag = generate_ising_from_graph(graph)  H = torch.diag(H_diag)  qc = QuantumCircuit(N) psi = qc.uniform_state(batch_size) psi_ini = copy.deepcopy(psi) In\u00a0[3]: Copied! <pre>t_range = torch.arange(0, 2*np.pi, 0.1)\nwf_save_rk  = torch.zeros((len(t_range),)+tuple(psi.shape)).cdouble()\nwf_save_eig = torch.zeros((len(t_range),)+tuple(psi.shape)).cdouble()\n</pre> t_range = torch.arange(0, 2*np.pi, 0.1) wf_save_rk  = torch.zeros((len(t_range),)+tuple(psi.shape)).cdouble() wf_save_eig = torch.zeros((len(t_range),)+tuple(psi.shape)).cdouble() In\u00a0[4]: Copied! <pre>import time\n\nstart = time.perf_counter()\nfor i, t in enumerate(t_range):\n    t_evo = torch.tensor([t])\n    psi = copy.deepcopy(psi_ini)\n    hamiltonian_evolution(H, psi, t_evo, range(N), N)\n    wf_save_rk[i]  = psi\nend = time.perf_counter()\n\nsecs = (end-start)\nprint(f\"RK4: {secs:.03f} secs.\")\n\nstart = time.perf_counter()\nfor i, t in enumerate(t_range):\n    t_evo = torch.tensor([t])\n    psi = copy.deepcopy(psi_ini)\n    hamiltonian_evolution_eig(H, psi, t_evo, range(N), N)\n    wf_save_eig[i]  = psi\nend = time.perf_counter()\n\nsecs = (end-start)\nprint(f\"Eig: {secs:.03f} secs.\")\n</pre> import time  start = time.perf_counter() for i, t in enumerate(t_range):     t_evo = torch.tensor([t])     psi = copy.deepcopy(psi_ini)     hamiltonian_evolution(H, psi, t_evo, range(N), N)     wf_save_rk[i]  = psi end = time.perf_counter()  secs = (end-start) print(f\"RK4: {secs:.03f} secs.\")  start = time.perf_counter() for i, t in enumerate(t_range):     t_evo = torch.tensor([t])     psi = copy.deepcopy(psi_ini)     hamiltonian_evolution_eig(H, psi, t_evo, range(N), N)     wf_save_eig[i]  = psi end = time.perf_counter()  secs = (end-start) print(f\"Eig: {secs:.03f} secs.\") <pre>RK4: 3.183 secs.\nEig: 0.038 secs.\n</pre> <p>The Hamiltonian is diagonal so the eig function skips the diagonalization and is very efficient.</p> In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\n\nnorm_rk = torch.tensor([(abs(wf_save_rk[i,...])**2).sum() for i in range(len(t_range))])\nnorm_eig = torch.tensor([(abs(wf_save_eig[i,...])**2).sum() for i in range(len(t_range))])\n\nplt.plot(t_range, norm_rk, label = \"RK4\")\nplt.plot(t_range, norm_eig, label = \"Eig\")\nplt.ylim(0.95, 1.01)\nplt.ylabel(\"Normalization |&lt;psi|psi&gt;|^2\")\nplt.xlabel(\"Time t\")\nplt.legend()\n</pre> import matplotlib.pyplot as plt  norm_rk = torch.tensor([(abs(wf_save_rk[i,...])**2).sum() for i in range(len(t_range))]) norm_eig = torch.tensor([(abs(wf_save_eig[i,...])**2).sum() for i in range(len(t_range))])  plt.plot(t_range, norm_rk, label = \"RK4\") plt.plot(t_range, norm_eig, label = \"Eig\") plt.ylim(0.95, 1.01) plt.ylabel(\"Normalization ||^2\") plt.xlabel(\"Time t\") plt.legend() Out[5]: <pre>&lt;matplotlib.legend.Legend at 0x117d82340&gt;</pre> <p>It is also exact, maintaining the normalization of the wavefunction.</p> In\u00a0[6]: Copied! <pre>diff = torch.tensor([torch.max(abs(wf_save_rk[i,...] - wf_save_eig[i,...])) for i in range(len(t_range))])\n\nplt.plot(t_range, diff)\nplt.yscale(\"log\")\nplt.ylabel(\"Max(Abs(|psi_rk4&gt; - |psi_eig&gt;))\")\nplt.xlabel(\"Time t\")\n</pre> diff = torch.tensor([torch.max(abs(wf_save_rk[i,...] - wf_save_eig[i,...])) for i in range(len(t_range))])  plt.plot(t_range, diff) plt.yscale(\"log\") plt.ylabel(\"Max(Abs(|psi_rk4&gt; - |psi_eig&gt;))\") plt.xlabel(\"Time t\") Out[6]: <pre>Text(0.5, 0, 'Time t')</pre> <p>As we can see both methods give a similar result for small t but the difference increases exponentially due to the error in the RK4 method.</p> In\u00a0[7]: Copied! <pre>n_qubits: int = 10\nbatch_size: int = 1\n\nqc = QuantumCircuit(n_qubits)\npsi = qc.uniform_state(batch_size)\npsi_ini = copy.deepcopy(psi)\n\nH_0 = torch.randn((2**n_qubits, 2**n_qubits), dtype = torch.double)\nH0 = (H_0 + torch.conj(H_0.transpose(0, 1))).cdouble()\n\nH_1 = torch.randn((2**n_qubits, 2**n_qubits), dtype = torch.double)\nH1 = (H_1 + torch.conj(H_1.transpose(0, 1))).cdouble()\n</pre> n_qubits: int = 10 batch_size: int = 1  qc = QuantumCircuit(n_qubits) psi = qc.uniform_state(batch_size) psi_ini = copy.deepcopy(psi)  H_0 = torch.randn((2**n_qubits, 2**n_qubits), dtype = torch.double) H0 = (H_0 + torch.conj(H_0.transpose(0, 1))).cdouble()  H_1 = torch.randn((2**n_qubits, 2**n_qubits), dtype = torch.double) H1 = (H_1 + torch.conj(H_1.transpose(0, 1))).cdouble() In\u00a0[8]: Copied! <pre>import time\n\nn_trials = 2\nwf_save_eig = torch.zeros((n_trials,)+tuple(psi.shape)).cdouble()\n\nprint(\"First Hamiltonian\")\nfor i in range(n_trials):\n    H = H0\n    start = time.time()\n    t_evo = torch.rand(batch_size)*0.5\n\n    psi = copy.deepcopy(psi_ini)\n    hamiltonian_evolution_eig(H, psi, t_evo, range(n_qubits), n_qubits)\n    wf_save_eig[i] = psi\n    end = time.time()\n    print(\"Timing:\", end-start)\n\nprint(\"Second Hamiltonian\")\nfor i in range(n_trials):\n    H = H1\n    start = time.time()\n    t_evo = torch.rand(batch_size)*0.5\n\n    psi = copy.deepcopy(psi_ini)\n    hamiltonian_evolution_eig(H, psi, t_evo, range(n_qubits), n_qubits)\n    wf_save_eig[i] = psi\n    end = time.time()\n    print(\"Timing:\", end-start)\n\nprint(\"First Hamiltonian again\")\nfor i in range(n_trials):\n    H = H0\n    start = time.time()\n    t_evo = torch.rand(batch_size)*0.5\n\n    psi = copy.deepcopy(psi_ini)\n    hamiltonian_evolution_eig(H, psi, t_evo, range(n_qubits), n_qubits)\n    wf_save_eig[i] = psi\n    end = time.time()\n    print(\"Timing:\", end-start)\n</pre> import time  n_trials = 2 wf_save_eig = torch.zeros((n_trials,)+tuple(psi.shape)).cdouble()  print(\"First Hamiltonian\") for i in range(n_trials):     H = H0     start = time.time()     t_evo = torch.rand(batch_size)*0.5      psi = copy.deepcopy(psi_ini)     hamiltonian_evolution_eig(H, psi, t_evo, range(n_qubits), n_qubits)     wf_save_eig[i] = psi     end = time.time()     print(\"Timing:\", end-start)  print(\"Second Hamiltonian\") for i in range(n_trials):     H = H1     start = time.time()     t_evo = torch.rand(batch_size)*0.5      psi = copy.deepcopy(psi_ini)     hamiltonian_evolution_eig(H, psi, t_evo, range(n_qubits), n_qubits)     wf_save_eig[i] = psi     end = time.time()     print(\"Timing:\", end-start)  print(\"First Hamiltonian again\") for i in range(n_trials):     H = H0     start = time.time()     t_evo = torch.rand(batch_size)*0.5      psi = copy.deepcopy(psi_ini)     hamiltonian_evolution_eig(H, psi, t_evo, range(n_qubits), n_qubits)     wf_save_eig[i] = psi     end = time.time()     print(\"Timing:\", end-start) <pre>First Hamiltonian\nTiming: 0.29912304878234863\nTiming: 0.07640600204467773\nSecond Hamiltonian\nTiming: 0.27396464347839355\nTiming: 0.08124589920043945\nFirst Hamiltonian again\nTiming: 0.08870816230773926\nTiming: 0.07958817481994629\n</pre> In\u00a0[9]: Copied! <pre>import torch\nimport numpy as np\nimport networkx as nx\n\nfrom pyqtorch.core.circuit import QuantumCircuit\nfrom pyqtorch.core.operation import hamiltonian_evolution, hamiltonian_evolution_eig\nfrom pyqtorch.core.batched_operation import batched_hamiltonian_evolution, batched_hamiltonian_evolution_eig\nimport copy\n</pre> import torch import numpy as np import networkx as nx  from pyqtorch.core.circuit import QuantumCircuit from pyqtorch.core.operation import hamiltonian_evolution, hamiltonian_evolution_eig from pyqtorch.core.batched_operation import batched_hamiltonian_evolution, batched_hamiltonian_evolution_eig import copy <p>Let's create a batch of hamiltonians that are just repeating the same hamiltonian.</p> In\u00a0[10]: Copied! <pre>N = 5\nbatch_size = 10\n\nqc = QuantumCircuit(N)\n\npsi = qc.uniform_state(batch_size)\npsi_0 = copy.deepcopy(psi)\n\nH_batch = torch.zeros((2**N, 2**N, batch_size), dtype = torch.cdouble)\nfor i in range(batch_size):\n    H_0 = torch.randn((2**N, 2**N), dtype = torch.cdouble)\n    H = (H_0 + torch.conj(H_0.transpose(0, 1))).cdouble()\n    H_batch[...,i] = H\n</pre> N = 5 batch_size = 10  qc = QuantumCircuit(N)  psi = qc.uniform_state(batch_size) psi_0 = copy.deepcopy(psi)  H_batch = torch.zeros((2**N, 2**N, batch_size), dtype = torch.cdouble) for i in range(batch_size):     H_0 = torch.randn((2**N, 2**N), dtype = torch.cdouble)     H = (H_0 + torch.conj(H_0.transpose(0, 1))).cdouble()     H_batch[...,i] = H <p>Now we create a batch of linearly increasing times.</p> In\u00a0[11]: Copied! <pre>t_size = batch_size\nt_start = 0.0\nt_end = 5.0\nt_evo = torch.arange(t_start, t_end, (t_end-t_start)/t_size).cdouble()\n</pre> t_size = batch_size t_start = 0.0 t_end = 5.0 t_evo = torch.arange(t_start, t_end, (t_end-t_start)/t_size).cdouble() <p>Now we evaluate the batched time-evolution, essentially evaluating the same generator for an increasing time. First with the RK4 method:</p> In\u00a0[12]: Copied! <pre>import time\npsi = copy.deepcopy(psi_0)\nstart = time.time()\npsi = batched_hamiltonian_evolution(H_batch, psi, t_evo, range(N), N)\nend = time.time()\npsi_save_rk = copy.deepcopy(psi)\nprint(end-start)\n</pre> import time psi = copy.deepcopy(psi_0) start = time.time() psi = batched_hamiltonian_evolution(H_batch, psi, t_evo, range(N), N) end = time.time() psi_save_rk = copy.deepcopy(psi) print(end-start) <pre>0.07417893409729004\n</pre> <p>And then with the eigenvalue method:</p> In\u00a0[13]: Copied! <pre>psi = copy.deepcopy(psi_0)\nstart = time.time()\npsi = batched_hamiltonian_evolution_eig(H_batch, psi, t_evo, range(N), N)\nend = time.time()\npsi_save_eig = copy.deepcopy(psi)\nprint(end-start)\n</pre> psi = copy.deepcopy(psi_0) start = time.time() psi = batched_hamiltonian_evolution_eig(H_batch, psi, t_evo, range(N), N) end = time.time() psi_save_eig = copy.deepcopy(psi) print(end-start) <pre>0.005017757415771484\n</pre> <p>Now we can compare the wavefunction normalization of both as t increases:</p> In\u00a0[14]: Copied! <pre>import matplotlib.pyplot as plt\n\nt_range = t_evo.real\n\nnorm_rk = torch.tensor([(abs(psi_save_rk[...,b])**2).sum() for b in range(batch_size)])\nnorm_eig = torch.tensor([(abs(psi_save_eig[...,b])**2).sum() for b in range(batch_size)])\n\nplt.plot(t_range, norm_rk, label = \"RK4\")\nplt.plot(t_range, norm_eig, label = \"Eig\")\nplt.ylim(0.95, 1.01)\nplt.ylabel(\"Normalization |&lt;psi|psi&gt;|^2\")\nplt.xlabel(\"Time t\")\nplt.legend()\n</pre> import matplotlib.pyplot as plt  t_range = t_evo.real  norm_rk = torch.tensor([(abs(psi_save_rk[...,b])**2).sum() for b in range(batch_size)]) norm_eig = torch.tensor([(abs(psi_save_eig[...,b])**2).sum() for b in range(batch_size)])  plt.plot(t_range, norm_rk, label = \"RK4\") plt.plot(t_range, norm_eig, label = \"Eig\") plt.ylim(0.95, 1.01) plt.ylabel(\"Normalization ||^2\") plt.xlabel(\"Time t\") plt.legend() Out[14]: <pre>&lt;matplotlib.legend.Legend at 0x137aaf7c0&gt;</pre> <p>And also the difference between the wavefunctions as t increases:</p> In\u00a0[15]: Copied! <pre>diff = torch.tensor([torch.max(abs(psi_save_rk[..., b] - psi_save_eig[..., b])) for b in range(batch_size)])\n\nplt.plot(t_range, diff)\nplt.yscale(\"log\")\nplt.ylabel(\"Max(Abs(|psi_rk4&gt; - |psi_eig&gt;))\")\nplt.xlabel(\"Time t\")\n</pre> diff = torch.tensor([torch.max(abs(psi_save_rk[..., b] - psi_save_eig[..., b])) for b in range(batch_size)])  plt.plot(t_range, diff) plt.yscale(\"log\") plt.ylabel(\"Max(Abs(|psi_rk4&gt; - |psi_eig&gt;))\") plt.xlabel(\"Time t\") Out[15]: <pre>Text(0.5, 0, 'Time t')</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"deprecated/ham_evol_comparison/#comparing-the-single-hamiltonian-evolution","title":"Comparing the single hamiltonian evolution\u00b6","text":"<p>Here we use an Ising hamiltonian over a graph, which is diagonal</p>"},{"location":"deprecated/ham_evol_comparison/#hamiltonian-caching","title":"Hamiltonian caching:\u00b6","text":"<p>The results of hamiltonian diagonalization are cached for repeated use:</p>"},{"location":"deprecated/ham_evol_comparison/#comparing-the-batched-hamiltonian-evolution","title":"Comparing the batched hamiltonian evolution:\u00b6","text":"<p>Here we use general hermitian matrices as hamiltonians</p>"},{"location":"deprecated/state_evolution/","title":"State evolution","text":"<p>This tutorial shows how to apply the <code>hamiltonian_evolution</code> operator to evolve the quantum state using an approximated but efficient matrix exponentiation.</p> In\u00a0[1]: Copied! <pre>from pyqtorch.matrices import single_Z, ZZ\nfrom pyqtorch.ansatz import AlternateLayerAnsatz, OneLayerXRotation, OneLayerZRotation, OneLayerEntanglingAnsatz\nfrom pyqtorch.core.circuit import QuantumCircuit\n</pre> from pyqtorch.matrices import single_Z, ZZ from pyqtorch.ansatz import AlternateLayerAnsatz, OneLayerXRotation, OneLayerZRotation, OneLayerEntanglingAnsatz from pyqtorch.core.circuit import QuantumCircuit <pre>/home/mdagrada/.cache/pypoetry/virtualenvs/qucint-YinaOvwL-py3.8/lib/python3.8/site-packages/tqdm/auto.py:22: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>import torch as th\nimport numpy as np\nimport copy\n</pre> import torch as th import numpy as np import copy <p>We start initialising the <code>QuantumCircuit</code> instance in order to observe the typical shape of an input/output state in the PyQ format</p> In\u00a0[3]: Copied! <pre>N = 4\nqc = QuantumCircuit(N)\npsi = qc.uniform_state(1)\npsi_0 = copy.deepcopy(psi)\npsi_0.shape\n</pre> N = 4 qc = QuantumCircuit(N) psi = qc.uniform_state(1) psi_0 = copy.deepcopy(psi) psi_0.shape Out[3]: <pre>torch.Size([2, 2, 2, 2, 1])</pre> <p>We perform a deepcopy of <code>psi</code> as some operations below (e.g. <code>hamiltonian evolution</code>) will overwrite it.</p> In\u00a0[4]: Copied! <pre>def overlap(state1, state2):\n    N = len(state1.shape)-1\n    state1_T = th.transpose(state1, N, 0)\n    overlap = th.tensordot(state1.T.conj(), state2, dims=N)\n    return float(th.abs(overlap**2).flatten())\n</pre> def overlap(state1, state2):     N = len(state1.shape)-1     state1_T = th.transpose(state1, N, 0)     overlap = th.tensordot(state1.T.conj(), state2, dims=N)     return float(th.abs(overlap**2).flatten()) In\u00a0[5]: Copied! <pre>print(\"Initial overlap: \", overlap(psi_0, psi_0))\n</pre> print(\"Initial overlap: \", overlap(psi_0, psi_0)) <pre>Initial overlap:  1.0\n</pre> <pre>/tmp/ipykernel_601/4268046128.py:4: UserWarning: The use of `x.T` on tensors of dimension other than 2 to reverse their shape is deprecated and it will throw an error in a future release. Consider `x.mT` to transpose batches of matrices or `x.permute(*torch.arange(x.ndim - 1, -1, -1))` to reverse the dimensions of a tensor. (Triggered internally at ../aten/src/ATen/native/TensorShape.cpp:3277.)\n  overlap = th.tensordot(state1.T.conj(), state2, dims=N)\n</pre> In\u00a0[6]: Copied! <pre>from pyqtorch.core.operation import hamiltonian_evolution\n</pre> from pyqtorch.core.operation import hamiltonian_evolution <p>Now let us define a simple Hamiltonian for the 4-qubits system, like a $\\sigma_Z \\otimes \\sigma_Z$, in dense format as a $(N^2, N^2)$ tensor</p> In\u00a0[7]: Copied! <pre>sigmaz = th.diag(th.tensor([1.0, -1.0], dtype=th.cdouble))\nHbase = th.kron(sigmaz, sigmaz)\nH = th.kron(Hbase, Hbase)\nH.shape\n</pre> sigmaz = th.diag(th.tensor([1.0, -1.0], dtype=th.cdouble)) Hbase = th.kron(sigmaz, sigmaz) H = th.kron(Hbase, Hbase) H.shape Out[7]: <pre>torch.Size([16, 16])</pre> <p>The overlap with itself should stay 1 after evolving for $t=0$, let's check this</p> In\u00a0[8]: Copied! <pre>t_evo = th.tensor([0], dtype=th.cdouble)\npsi = hamiltonian_evolution(H,\n                    psi, t_evo,\n                    range(N), N)\n</pre> t_evo = th.tensor([0], dtype=th.cdouble) psi = hamiltonian_evolution(H,                     psi, t_evo,                     range(N), N) In\u00a0[9]: Copied! <pre>print(f\"Overlap after {t_evo} : \", overlap(psi, psi_0))\n</pre> print(f\"Overlap after {t_evo} : \", overlap(psi, psi_0)) <pre>Overlap after tensor([0.+0.j], dtype=torch.complex128) :  1.0\n</pre> <p>Let's now evolve the state for a time $t = \\pi/4$ and check that the overlap matches the expected value of 0.5.</p> In\u00a0[10]: Copied! <pre>t_evo = th.tensor([th.pi/4], dtype=th.cdouble)\npsi = hamiltonian_evolution(H,\n                    psi, t_evo,\n                    range(N), N\n    )\n</pre> t_evo = th.tensor([th.pi/4], dtype=th.cdouble) psi = hamiltonian_evolution(H,                     psi, t_evo,                     range(N), N     ) In\u00a0[11]: Copied! <pre>print(f\"Overlap after {t_evo} : \", overlap(psi, psi_0))\n</pre> print(f\"Overlap after {t_evo} : \", overlap(psi, psi_0)) <pre>Overlap after tensor([0.7854+0.j], dtype=torch.complex128) :  0.50000000002474\n</pre>"},{"location":"deprecated/state_evolution/#hamiltonian-evolution","title":"Hamiltonian Evolution\u00b6","text":""}]}