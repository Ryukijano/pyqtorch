{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pyqtorch","text":"<p>pyqtorch is a state vector simulator designed for quantum machine learning written in PyTorch. It allows for building fully differentiable quantum circuits comprised of both digital and analog operations using a intuitive torch.nn.Module-based API.</p>"},{"location":"#setup","title":"Setup","text":"<p>To install <code>pyqtorch</code> , you can go into any virtual environment of your choice and install it normally with <code>pip</code>:</p> <pre><code>pip install pyqtorch\n</code></pre>"},{"location":"#digital-operations","title":"Digital Operations","text":"<p><code>pyqtorch</code> implements a large selection of both primitive and parametric single to n-qubit, digital quantum gates.</p> <p>Let's have a look at primitive gates first.</p> <pre><code>import torch\nfrom pyqtorch import X, CNOT, random_state\n\nx = X(0)\nstate = random_state(n_qubits=2)\n\nnew_state = x(state)\n\ncnot = CNOT(0,1)\nnew_state= cnot(state)\n</code></pre> <p>Parametric gates can be initialized with or without a <code>param_name</code>. In the former case, a dictionary containing the <code>param_name</code> and a <code>torch.Tensor</code> for the parameter is expected when calling the forward method of the gate.</p> <pre><code>import torch\nfrom pyqtorch import X, RX, CNOT, CRX, random_state\n\nstate = random_state(n_qubits=2)\n\nrx_with_param = RX(0, 'theta')\n\ntheta = torch.rand(1)\nvalues = {'theta': theta}\nnew_state = rx_with_param(state, values)\n\ncrx = CRX(0, 1, 'theta')\nnew_state = crx(state, values)\n</code></pre> <p>However, if you want to run a quick state vector simulation, you can initialize parametric gates without passing a <code>param_name</code>, in which case the forward method of the gate will simply expect a <code>torch.Tensor</code>.</p> <pre><code>import torch\nfrom pyqtorch import RX, random_state\n\nstate = random_state(n_qubits=2)\nrx = RX(0)\nnew_state = rx(state, torch.rand(1))\n</code></pre>"},{"location":"#analog-operations","title":"Analog Operations","text":"<p><code>pyqtorch</code> also contains a <code>analog</code> module which allows for global state evolution through the <code>HamiltonianEvolution</code> class. Note that it only accepts a <code>torch.Tensor</code> as a generator which is expected to be an Hermitian matrix. To build arbitrary Pauli hamiltonians, we recommend using Qadence.</p> <pre><code>import torch\nfrom pyqtorch import uniform_state, HamiltonianEvolution, is_normalized\nfrom pyqtorch.matrices import DEFAULT_MATRIX_DTYPE\n\nn_qubits = 4\n\n# Random hermitian hamiltonian\nmatrix = torch.rand(2**n_qubits, 2**n_qubits, dtype=DEFAULT_MATRIX_DTYPE)\nhermitian_matrix = matrix + matrix.T.conj()\n\n# To be evolved for a batch of times\nt_list = torch.tensor([0.0, 0.5, 1.0, 2.0])\n\nhamiltonian_evolution = HamiltonianEvolution(qubit_support=[i for i in range(n_qubits)])\n\n# Starting from a uniform state\npsi_start = uniform_state(n_qubits)\n\n# Returns an evolved state at each time value\npsi_end = hamiltonian_evolution(\n    hamiltonian=hermitian_matrix,\n    time_evolution=t_list,\n    state = psi_start)\n\nassert is_normalized(psi_end, atol=1e-05)\n</code></pre>"},{"location":"#circuits","title":"Circuits","text":"<p>Using digital and analog operations, you can can build fully differentiable quantum circuits using the <code>QuantumCircuit</code> class; note that the default differentiation mode in pyqtorch is using torch.autograd.</p> <pre><code>import torch\nimport pyqtorch as pyq\n\nrx = pyq.RX(0, param_name=\"theta\")\ny = pyq.Y(0)\ncnot = pyq.CNOT(0, 1)\nops = [rx, y, cnot]\nn_qubits = 2\ncirc = pyq.QuantumCircuit(n_qubits, ops)\nstate = pyq.random_state(n_qubits)\ntheta = torch.rand(1, requires_grad=True)\nobs = pyq.QuantumCircuit(n_qubits, [pyq.Z(0)])\nexpval = pyq.expectation(circ, state, {\"theta\": theta}, obs)\ndfdtheta = torch.autograd.grad(expval, theta, torch.ones_like(expval))\n</code></pre>"},{"location":"#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p><code>pyqtorch</code> also offers a adjoint differentiation mode which can be used through the <code>expectation</code> method.</p> <pre><code>import pyqtorch as pyq\nimport torch\nfrom pyqtorch.utils import DiffMode\n\nn_qubits = 3\nbatch_size = 1\n\nrx = pyq.RX(0, param_name=\"x\")\ncnot = pyq.CNOT(1, 2)\nops = [rx, cnot]\nn_qubits = 3\ncirc = pyq.QuantumCircuit(n_qubits, ops)\n\nobs = pyq.QuantumCircuit(n_qubits, [pyq.Z(0)])\nstate = pyq.zero_state(n_qubits)\n\nvalues_ad = {\"x\": torch.tensor([torch.pi / 2], requires_grad=True)}\nvalues_adjoint = {\"x\": torch.tensor([torch.pi / 2], requires_grad=True)}\nexp_ad = pyq.expectation(circ, state, values_ad, obs, DiffMode.AD)\nexp_adjoint = pyq.expectation(circ, state, values_adjoint, obs, DiffMode.ADJOINT)\n\ndfdx_ad = torch.autograd.grad(exp_ad, tuple(values_ad.values()), torch.ones_like(exp_ad))\n\ndfdx_adjoint = torch.autograd.grad(\n    exp_adjoint, tuple(values_adjoint.values()), torch.ones_like(exp_adjoint)\n)\n\nassert len(dfdx_ad) == len(dfdx_adjoint)\nfor i in range(len(dfdx_ad)):\n    assert torch.allclose(dfdx_ad[i], dfdx_adjoint[i])\n</code></pre>"},{"location":"#fitting-a-nonlinear-function","title":"Fitting a nonlinear function","text":"<p>Let's have a look at how the <code>QuantumCircuit</code> can be used to fit a function.</p> <pre><code>from __future__ import annotations\n\nfrom operator import add\nfrom functools import reduce\nimport torch\nimport pyqtorch as pyq\nfrom pyqtorch.circuit import hea\nfrom pyqtorch.utils import DiffMode\nfrom pyqtorch.parametric import Parametric\nimport matplotlib.pyplot as plt\n\nfrom torch.nn.functional import mse_loss\n\n# We can train on GPU if available\nDEVICE = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')\n# We can also choose the precision we want to train on\nCOMPLEX_DTYPE = torch.complex64\nREAL_DTYPE = torch.float32\nN_QUBITS = 4\nDEPTH = 2\nLR = .2\nDIFF_MODE = DiffMode.ADJOINT\nN_EPOCHS = 75\n\n# Target function and some training data\nfn = lambda x, degree: .05 * reduce(add, (torch.cos(i*x) + torch.sin(i*x) for i in range(degree)), 0)\nx = torch.linspace(0, 10, 100)\ny = fn(x, 5)\n# Lets define a feature map to encode our 'x' values\nfeature_map = [pyq.RX(i, f'x') for i in range(N_QUBITS)]\n# To fit the function, we define a hardware-efficient ansatz with tunable parameters\nansatz, params = hea(N_QUBITS, DEPTH, 'theta')\n# Lets move all necessary components to the DEVICE\ncirc = pyq.QuantumCircuit(N_QUBITS, feature_map + ansatz).to(device=DEVICE, dtype=COMPLEX_DTYPE)\nobservable = pyq.Hamiltonian([pyq.Z(0)]).to(device=DEVICE, dtype=COMPLEX_DTYPE)\nparams = params.to(device=DEVICE, dtype=REAL_DTYPE)\nx, y = x.to(device=DEVICE, dtype=REAL_DTYPE), y.to(device=DEVICE, dtype=REAL_DTYPE)\nstate = circ.init_state()\n\ndef exp_fn(params: dict[str, torch.Tensor], inputs: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n    return pyq.expectation(circ, state, {**params,**inputs}, observable, DIFF_MODE)\n\nwith torch.no_grad():\n    y_init = exp_fn(params, {'x': x})\n\n# We need to set 'foreach' False since Adam doesnt support float64 on CUDA devices\noptimizer = torch.optim.Adam(params.values(), lr=LR, foreach=False)\n\nfor _ in range(N_EPOCHS):\n    optimizer.zero_grad()\n    y_pred = exp_fn(params, {'x': x})\n    loss = mse_loss(y, y_pred)\n    loss.backward()\n    optimizer.step()\n\nwith torch.no_grad():\n    y_final = exp_fn(params, {'x': x})\n\nplt.plot(x.numpy(), y.numpy(), label=\"truth\")\nplt.plot(x.numpy(), y_init.numpy(), label=\"initial\")\nplt.plot(x.numpy(), y_final.numpy(), \"--\", label=\"final\", linewidth=3)\nplt.legend()\n</code></pre> 2024-05-29T08:52:15.607370 image/svg+xml Matplotlib v3.9.0, https://matplotlib.org/"},{"location":"#fitting-a-partial-differential-equation-using-dqc","title":"Fitting a partial differential equation using DQC","text":"<p>Finally, we show how to implement DQC to solve a partial differential equation using <code>pyqtorch</code>.</p> <pre><code>from __future__ import annotations\n\nfrom functools import reduce\nfrom itertools import product\nfrom operator import add\nfrom typing import Callable\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom torch import Tensor, exp, linspace, ones_like, optim, rand, sin, tensor\nfrom torch.autograd import grad\nfrom pyqtorch.circuit import hea\nfrom pyqtorch import CNOT, RX, RY, QuantumCircuit, Z, expectation, Hamiltonian, Sequence, Merge\nfrom pyqtorch.parametric import Parametric\nfrom pyqtorch.utils import DiffMode\n\nDIFF_MODE = DiffMode.AD\nDEVICE = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n# We can also choose the precision we want to train on\nCOMPLEX_DTYPE = torch.complex64\nREAL_DTYPE = torch.float32\nLR = .15\nN_QUBITS = 4\nDEPTH = 3\nVARIABLES = (\"x\", \"y\")\nN_VARIABLES = len(VARIABLES)\nX_POS, Y_POS = [i for i in range(N_VARIABLES)]\nBATCH_SIZE = 250\nN_EPOCHS = 750\n\n\nclass DomainSampling(torch.nn.Module):\n    def __init__(\n        self, exp_fn: Callable[[Tensor], Tensor], n_inputs: int, batch_size: int, device: torch.device, dtype: torch.dtype\n    ) -&gt; None:\n        super().__init__()\n        self.exp_fn = exp_fn\n        self.n_inputs = n_inputs\n        self.batch_size = batch_size\n        self.device = device\n        self.dtype = dtype\n\n    def sample(self, requires_grad: bool = False) -&gt; Tensor:\n        return rand((self.batch_size, self.n_inputs), requires_grad=requires_grad, device=self.device, dtype=self.dtype)\n\n    def left_boundary(self) -&gt; Tensor:  # u(0,y)=0\n        sample = self.sample()\n        sample[:, X_POS] = 0.0\n        return self.exp_fn(sample).pow(2).mean()\n\n    def right_boundary(self) -&gt; Tensor:  # u(L,y)=0\n        sample = self.sample()\n        sample[:, X_POS] = 1.0\n        return self.exp_fn(sample).pow(2).mean()\n\n    def top_boundary(self) -&gt; Tensor:  # u(x,H)=0\n        sample = self.sample()\n        sample[:, Y_POS] = 1.0\n        return self.exp_fn(sample).pow(2).mean()\n\n    def bottom_boundary(self) -&gt; Tensor:  # u(x,0)=f(x)\n        sample = self.sample()\n        sample[:, Y_POS] = 0.0\n        return (self.exp_fn(sample) - sin(np.pi * sample[:, 0])).pow(2).mean()\n\n    def interior(self) -&gt; Tensor:  # uxx+uyy=0\n        sample = self.sample(requires_grad=True)\n        f = self.exp_fn(sample)\n        dfdxy = grad(\n            f,\n            sample,\n            ones_like(f),\n            create_graph=True,\n        )[0]\n        dfdxxdyy = grad(\n            dfdxy,\n            sample,\n            ones_like(dfdxy),\n        )[0]\n\n        return (dfdxxdyy[:, X_POS] + dfdxxdyy[:, Y_POS]).pow(2).mean()\n\n\nfeature_map = [RX(i, VARIABLES[X_POS]) for i in range(N_QUBITS // 2)] + [\n    RX(i, VARIABLES[Y_POS]) for i in range(N_QUBITS // 2, N_QUBITS)\n]\nansatz, params = hea(N_QUBITS, DEPTH, \"theta\")\ncirc = QuantumCircuit(N_QUBITS, feature_map + ansatz).to(device=DEVICE, dtype=COMPLEX_DTYPE)\ntotal_magnetization = Hamiltonian([Z(i) for i in range(N_QUBITS)]).to(device=DEVICE, dtype=COMPLEX_DTYPE)\nparams = params.to(device=DEVICE, dtype=REAL_DTYPE)\nstate = circ.init_state()\n\n\ndef exp_fn(inputs: Tensor) -&gt; Tensor:\n    return expectation(\n        circ,\n        state,\n        {**params, **{VARIABLES[X_POS]: inputs[:, X_POS], VARIABLES[Y_POS]: inputs[:, Y_POS]}},\n        total_magnetization,\n        DIFF_MODE,\n    )\n\n\nsingle_domain_torch = linspace(0, 1, steps=BATCH_SIZE)\ndomain_torch = tensor(list(product(single_domain_torch, single_domain_torch)))\n\nopt = optim.Adam(params.values(), lr=LR)\nsol = DomainSampling(exp_fn, len(VARIABLES), BATCH_SIZE, DEVICE, REAL_DTYPE)\n\nfor _ in range(N_EPOCHS):\n    opt.zero_grad()\n    loss = (\n        sol.left_boundary()\n        + sol.right_boundary()\n        + sol.top_boundary()\n        + sol.bottom_boundary()\n        + sol.interior()\n    )\n    loss.backward()\n    opt.step()\n\ndqc_sol = exp_fn(domain_torch.to(DEVICE)).reshape(BATCH_SIZE, BATCH_SIZE).detach().cpu().numpy()\nanalytic_sol = (\n    (exp(-np.pi * domain_torch[:, X_POS]) * sin(np.pi * domain_torch[:, Y_POS]))\n    .reshape(BATCH_SIZE, BATCH_SIZE)\n    .T\n).numpy()\n\n\nfig, ax = plt.subplots(1, 2, figsize=(7, 7))\nax[0].imshow(analytic_sol, cmap=\"turbo\")\nax[0].set_xlabel(\"x\")\nax[0].set_ylabel(\"y\")\nax[0].set_title(\"Analytical solution u(x,y)\")\nax[1].imshow(dqc_sol, cmap=\"turbo\")\nax[1].set_xlabel(\"x\")\nax[1].set_ylabel(\"y\")\nax[1].set_title(\"DQC solution\")\n</code></pre> 2024-05-29T08:53:40.012827 image/svg+xml Matplotlib v3.9.0, https://matplotlib.org/"},{"location":"#cuda-profiling-and-debugging","title":"CUDA Profiling and debugging","text":"<p>To debug your quantum programs on <code>CUDA</code> devices, <code>pyqtorch</code> offers a <code>DEBUG</code> mode, which can be activated via setting the <code>PYQ_LOG_LEVEL</code> environment variable.</p> <pre><code>export PYQ_LOG_LEVEL=DEBUG\n</code></pre> <p>Before running your script, make sure to install the following packages:</p> <p><pre><code>pip install nvidia-pyindex\npip install nvidia-dlprof[pytorch]\n</code></pre> For more information, check the dlprof docs.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to Contribute","text":"<p>We're grateful for your interest in participating in pyqtorch! Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an Issue or Proposing a Feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to PyQ, feel free to create an issue on pyqtorch's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>We're excited that you're eager to contribute to pyqtorch! To contribute, fork the <code>main</code> branch of pyqtorch repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/pyqtorch</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/pyqtorch.git\n</code></pre> <p>Next, navigate to your new pyqtorch fork directory and mark the main pyqtorch repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/pyqtorch.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within pyqtorch, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run pyqtorch tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\n\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful Things for your workflow: Linting and Testing","text":"<p>Use <code>pre-commit</code> hooks to make sure that the code is properly linted before pushing a new commit. Make sure that the unit tests and type checks are passing since the merge request will not be accepted if the automatic CI/CD pipeline do not pass.</p> <p>Without <code>hatch</code>:</p> <pre><code>pip install pytest\n\npip install -e .\npip install pre-commit\npre-commit install\npre-commit run --all-files\npytest\n</code></pre> <p>And with <code>hatch</code>:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Make sure your docs build too!</p> <p>With <code>hatch</code>:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"}]}